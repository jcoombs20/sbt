<!DOCTYPE html>
<html>
  <head>
    <title>Southern Brook Trout Population Structure</title>
    <link rel="icon" type="image/png" href="images/favicon.ico">

    <!--link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css"/-->
    <link rel="stylesheet" href="styles/bootstrap.min.css"/>
    <link rel="stylesheet" href="fonts/icomoon/style.css"/>
    <!--link rel="stylesheet" href="https://gitcdn.github.io/bootstrap-toggle/2.2.2/css/bootstrap-toggle.min.css"/-->
    <link rel="stylesheet" href="styles/bootstrap-toggle.min.css"/>
    <!--link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/intro.js/2.4.0/introjs.min.css"/-->
    <link rel="stylesheet" href="introjs.min.css"/>
    <!--link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css"/-->
    <link rel="stylesheet" href="leaflet.css"/>
    <!--link rel="stylesheet" href="http://colorbrewer2.org/export/colorbrewer.css"/-->
    <link rel="stylesheet" href="colorbrewer.css"/>
    <link href="http://vjs.zencdn.net/5.16.0/video-js.css" rel="stylesheet">
    <link rel="stylesheet" href="styles/Control.BingGeocoder.css"/>
    <link rel="stylesheet" href="styles/Control.maxExtent.css"/>
    <link rel="stylesheet" href="styles/Control.mousePosition.css"/>
    <link rel="stylesheet" href="styles/Control.attrSelect.css"/>
    <!--link rel="stylesheet" href="styles/app.css"/-->
    <link rel="stylesheet" href="styles/deerfield_crossings.css"/>

    <!--script src="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.js"></script-->
    <script src="leaflet.js"></script>
    <!--script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script-->
    <script src="google.charts.js"></script>
    <!--script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script-->
    <script src="jquery-3.2.1.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <!--script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script-->
    <script src="bootstrap.min.js"></script>
    <!--script src="https://gitcdn.github.io/bootstrap-toggle/2.2.2/js/bootstrap-toggle.min.js"></script-->
    <script src="bootstrap-toggle.min.js"></script>    
    <!--script src="http://vjs.zencdn.net/5.16.0/video.js"></script-->
    <script src="video.js"></script>
    <script src="http://maps.google.com/maps/api/js?v=3"></script>
    <!--script src="google_maps.js"></script-->
    <script src="bundle.js"></script>
    <script src="Bing_tile.js"></script>
    <script src="Control.BingGeocoder.js"></script>
    <script src="Control.maxExtent.js"></script>
    <script src="Control.mousePosition.js"></script>
    <script src="Control.attrSelect.js"></script>
    <script src="Control.downLoadFile.js"></script>
    <!--script src="https://cdnjs.cloudflare.com/ajax/libs/intro.js/2.4.0/intro.min.js"></script-->
    <script type="text/javascript" src="intro.min.js"></script>

    <!--script src="http://d3js.org/d3.v3.min.js"></script-->
    <script src="d3.v3.min.js"></script>
    <!--script src="http://d3js.org/topojson.v1.min.js"></script-->
    <script src="topojson.v1.min.js"></script>
    <!--script src="http://colorbrewer2.org/export/colorbrewer.js"></script-->
    <script src="colorbrewer.js"></script>
    <!--script src="https://cdnjs.cloudflare.com/ajax/libs/queue-async/1.0.7/queue.min.js"></script-->
    <script src="queue.min.js"></script>
    <script src="crossfilter.min.js"></script>

  </head>

  <body>
    <div id="map"></div>

    <script type='text/javascript'>
      //******Initialize bootstrap tooltip
      $(document).ready(function(){
        $('[data-toggle="tooltip"]').tooltip();   
      });

      //******Call funtion to reposition windows on resize
      window.addEventListener('resize', resizePanels);

      function resizePanels() {
        var bodyRect = document.body.getBoundingClientRect();
        var tmpWindows = ["legendDiv", "chartsDiv", "polFilterDiv", "attrSelectDiv", "attributesDiv", "downloadDiv"];
        
        tmpWindows.forEach(function(win) {
          var winRect = document.getElementById(win).getBoundingClientRect();
          if(winRect.bottom > bodyRect.bottom) {
            d3.select("#" + win).style("top", bodyRect.height - winRect.height + "px");
          }
          if(winRect.right > bodyRect.right) {
            d3.select("#" + win).style("left", bodyRect.width - winRect.width + "px");
          }
        });
      }

      //******Add Map
      var map = new L.Map('map', {crs: L.CRS.EPSG3857, maxBounds: [[-90,-180],[90,180]], center: new L.LatLng(41, -76), zoomControl: false, zoom: 6, minZoom: 3, maxZoom: 20, inertiaDeceleration: 1000});
      d3.select(".leaflet-control-attribution a").property("target", "_blank")

      //******Add Google Charts
      google.charts.load('current', {'packages':['corechart']});

      //******Add base layers
      var googleHybrid = L.tileLayer('http://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}',{
        maxZoom: 20,
        subdomains:['mt0','mt1','mt2','mt3']
      });
      var googleSatellite = L.tileLayer('http://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',{
        maxZoom: 20,
        subdomains:['mt0','mt1','mt2','mt3']
      }); 
      var googleStreet = L.tileLayer('http://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',{
        maxZoom: 20,
        subdomains:['mt0','mt1','mt2','mt3']
      });
      var googleTerrain = googleTerrain = L.tileLayer('http://{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}',{
        maxZoom: 20,
        subdomains:['mt0','mt1','mt2','mt3']
      });

      var bingHybrid = new L.BingLayer("At3gymJqaoGjGje-JJ-R5tJOuilUk-gd7SQ0DBZlTXTsRoMfVWU08ZWF1X7QKRRn", {type: 'AerialWithLabels'});
      var bingSatellite = new L.BingLayer("At3gymJqaoGjGje-JJ-R5tJOuilUk-gd7SQ0DBZlTXTsRoMfVWU08ZWF1X7QKRRn", {type: 'Aerial'});
      var bingStreet = new L.BingLayer("At3gymJqaoGjGje-JJ-R5tJOuilUk-gd7SQ0DBZlTXTsRoMfVWU08ZWF1X7QKRRn", {type: 'Road'});
      var usgsTopo = new L.tileLayer('http://basemap.nationalmap.gov/ArcGIS/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 15,
            attribution: '<a href="http://www.doi.gov">U.S. Department of the Interior</a> | <a href="http://www.usgs.gov">U.S. Geological Survey</a> | <a href="http://www.usgs.gov/laws/policies_notices.html">Policies</a>'
            });
      var states = new L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/wms", {
          layers: 'us_states',
          format: 'image/png',
          transparent: true,
          version: '1.1.0',
          maxZoom: 20,
        });
      var blank = new L.tileLayer('');
    
      //******Add Geoserver Layers
      var gsStates = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/wms", {
        layers: 'BKT:us_states',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsContDiv = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/wms", {
        layers: 'BKT:east_cont_div',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsHuc2 = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/EBTJV/wms", {
        layers: 'EBTJV:HUC_2',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsHuc4 = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/EBTJV/wms", {
        layers: 'EBTJV:HUC_4',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsHuc6 = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/EBTJV/wms", {
        layers: 'EBTJV:HUC_6',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsHuc8 = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/EBTJV/wms", {
        layers: 'EBTJV:HUC_8',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsHuc10 = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/EBTJV/wms", {
        layers: 'EBTJV:HUC_10',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsHuc12 = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/EBTJV/wms", {
        layers: 'EBTJV:HUC_12',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsBktPatches = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/EBTJV/wms", {
        layers: 'EBTJV:ebtjv_patches_bkt_09_22_16_southern',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsNHDStreams = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/EBTJV/wms", {
        layers: 'EBTJV:NHDPlus2_Streams_wgs84',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsNHDWaterbodies = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/EBTJV/wms", {
        layers: 'EBTJV:NHDPlus2_Waterbody_wgs84',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });
/*
      var gsStruct_2k = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/gwc/service/wms", {
        layers: 'BKT:structure_2k',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsStruct_2k_hatch = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/wms", {
        layers: 'BKT:structure_2k_hatch',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsStruct_3k = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/gwc/service/wms", {
        layers: 'BKT:structure_3k',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsStruct_3k_hatch = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/wms", {
        layers: 'BKT:structure_3k_hatch',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsStruct_4k = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/gwc/service/wms", {
        layers: 'BKT:structure_4k',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsStruct_4k_hatch = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/wms", {
        layers: 'BKT:structure_4k_hatch',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsStruct_5k = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/gwc/service/wms", {
        layers: 'BKT:structure_5k',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsStruct_5k_hatch = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/wms", {
        layers: 'BKT:structure_5k_hatch',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsStruct_6k = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/gwc/service/wms", {
        layers: 'BKT:structure_6k',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsStruct_6k_hatch = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/wms", {
        layers: 'BKT:structure_6k_hatch',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsStruct_7k = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/gwc/service/wms", {
        layers: 'BKT:structure_7k',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsStruct_7k_hatch = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/wms", {
        layers: 'BKT:structure_7k_hatch',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

       var gsDapc_2k = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/gwc/service/wms", {
        layers: 'BKT:dapc_2k',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsDapc_2k_hatch = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/wms", {
        layers: 'BKT:dapc_2k_hatch',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

       var gsDapc_3k = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/gwc/service/wms", {
        layers: 'BKT:dapc_3k',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsDapc_3k_hatch = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/wms", {
        layers: 'BKT:dapc_3k_hatch',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

       var gsDapc_4k = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/gwc/service/wms", {
        layers: 'BKT:dapc_4k',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsDapc_4k_hatch = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/wms", {
        layers: 'BKT:dapc_4k_hatch',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

       var gsDapc_5k = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/gwc/service/wms", {
        layers: 'BKT:dapc_5k',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsDapc_5k_hatch = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/wms", {
        layers: 'BKT:dapc_5k_hatch',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

       var gsDapc_6k = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/gwc/service/wms", {
        layers: 'BKT:dapc_6k',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsDapc_6k_hatch = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/wms", {
        layers: 'BKT:dapc_6k_hatch',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

       var gsDapc_7k = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/gwc/service/wms", {
        layers: 'BKT:dapc_7k',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsDapc_7k_hatch = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/wms", {
        layers: 'BKT:dapc_7k_hatch',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

       var gsDapc_10k = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/gwc/service/wms", {
        layers: 'BKT:dapc_10k',
        format: 'image/png',
        tiled: true,
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });

      var gsDapc_10k_hatch = L.tileLayer.wms("http://felek.cns.umass.edu:8080/geoserver/BKT/wms", {
        layers: 'BKT:dapc_10k_hatch',
        format: 'image/png',
        transparent: true,
        version: '1.1.0',
        maxZoom: 20
      });
*/
     //var roads = L.esri.tiledMapLayer({url: "http://gis.massdot.state.ma.us/arcgis/rest/services/Roads/RoadInventory/MapServer"});

/*
      //******Make layer controller
      var baseLayers = {"Google Terrain": googleTerrain, "Google Hybrid": googleHybrid, "Google Satellite": googleSatellite, "Google Street": googleStreet, "Bing Hybrid": bingHybrid, "Bing Satellite": bingSatellite, "Bing Street": bingStreet, "USGS Topo": usgsTopo, "State Outlines": states, "None": blank};
      //var overlays = {"States": gsStates, "Continental Divide": gsContDiv, "HUC 6 Watersheds": gsHuc6, "HUC 8 Watersheds": gsHuc8, "HUC 10 Watersheds": gsHuc10, "HUC 12 Watersheds": gsHuc12, "Structure (K=2)": gsStruct_2k, "Structure (K=3)": gsStruct_3k, "Structure (K=4)": gsStruct_4k, "Structure (K=5)": gsStruct_5k, "Structure (K=6)": gsStruct_6k, "Structure (K=7)": gsStruct_7k, "DAPC (K=2)": gsDapc_2k, "DAPC (K=3)": gsDapc_3k, "DAPC (K=4)": gsDapc_4k, "DAPC (K=5)": gsDapc_5k, "DAPC (K=6)": gsDapc_6k, "DAPC (K=7)": gsDapc_7k, "DAPC (K=10)": gsDapc_10k};  
      var overlays = {"States": gsStates, "Continental Divide": gsContDiv, "HUC 2 Watersheds": gsHuc2, "HUC 4 Watersheds": gsHuc4, "HUC 6 Watersheds": gsHuc6, "HUC 8 Watersheds": gsHuc8, "HUC 10 Watersheds": gsHuc10, "HUC 12 Watersheds": gsHuc12, "Structure (K=2)": gsStruct_2k, "Structure (K=3)": gsStruct_3k, "Structure (K=4)": topos.struct.k4, "Structure (K=5)": gsStruct_5k, "Structure (K=6)": gsStruct_6k, "Structure (K=7)": gsStruct_7k, "DAPC (K=2)": gsDapc_2k, "DAPC (K=3)": gsDapc_3k, "DAPC (K=4)": topos.dapc.k4, "DAPC (K=5)": gsDapc_5k, "DAPC (K=6)": gsDapc_6k, "DAPC (K=7)": gsDapc_7k, "DAPC (K=10)": gsDapc_10k};  
      var overlaysHatch = {"States": gsStates, "Continental Divide": gsContDiv, "HUC 6 Watersheds": gsHuc6, "HUC 8 Watersheds": gsHuc8, "HUC 10 Watersheds": gsHuc10, "HUC 12 Watersheds": gsHuc12, "Structure Hatchery (K=2)": gsStruct_2k_hatch, "Structure Hatchery (K=3)": gsStruct_3k_hatch, "Structure Hatchery (K=4)": topos.hatchS.k4, "Structure Hatchery (K=5)": gsStruct_5k_hatch, "Structure Hatchery (K=6)": gsStruct_6k_hatch, "Structure Hatchery (K=7)": gsStruct_7k_hatch, "DAPC Hatchery (K=2)": gsDapc_2k_hatch, "DAPC Hatchery (K=3)": gsDapc_3k_hatch, "DAPC Hatchery (K=4)": gsDapc_4k_hatch, "DAPC Hatchery (K=5)": gsDapc_5k_hatch, "DAPC Hatchery (K=6)": gsDapc_6k_hatch, "DAPC Hatchery (K=7)": gsDapc_7k_hatch, "DAPC Hatchery (K=10)": gsDapc_10k_hatch};
      var overlaysPlots = {"States": null, "Continental Divide": null, "HUC 6 Watersheds": null, "HUC 8 Watersheds": null, "HUC 10 Watersheds": null, "HUC 12 Watersheds": null, "Structure (K=2)": "noplot", "Structure (K=3)": "noplot", "Structure (K=4)": "noplot", "Structure (K=5)": "noplot", "Structure (K=6)": "noplot", "Structure (K=7)": "noplot", "DAPC (K=2)": "dapc_K2", "DAPC (K=3)": "dapc_K3", "DAPC (K=4)": "dapc_K4", "DAPC (K=5)": "dapc_K5", "DAPC (K=6)": "dapc_K6", "DAPC (K=7)": "dapc_K7", "DAPC (K=10)": "dapc_K10"};
      var layerNames = {};
      layerNames.baseLayers = {};
      layerNames.baseLayers.keys = d3.keys(baseLayers);
      layerNames.baseLayers.values = d3.values(baseLayers);
      layerNames.overlays = {};
      layerNames.overlays.keys = d3.keys(overlays);
      layerNames.overlays.values = d3.values(overlays);
      layerNames.overlaysHatch = {};
      layerNames.overlaysHatch.keys = d3.keys(overlaysHatch);
      layerNames.overlaysHatch.values = d3.values(overlaysHatch);
      layerNames.overlaysPlots = {};
      layerNames.overlaysPlots.keys = d3.keys(overlaysPlots);
      layerNames.overlaysPlots.values = d3.values(overlaysPlots);
*/


      //******Add map controls
      //***Bottom Right
      L.control.zoom({ position: 'bottomright', zoomInTitle: "Zoom in (can also be done with mouse wheel, double-click, '+' key, or by pressing the 'shift' key while clicking and dragging a rectangle)", zoomOutTitle: "Zoom out (can also be done with the mouse wheel or the '-' key)" }).addTo(map);
      L.control.maxExtent().addTo(map);

      //***Bottom Left
      L.control.scale({ maxWidth: 200 }).addTo(map);
      L.control.mousePosition().addTo(map);


      //***Bing geocoder control
      var tmpPoint = new L.marker;
      var bingGeocoder = new L.Control.BingGeocoder('At3gymJqaoGjGje-JJ-R5tJOuilUk-gd7SQ0DBZlTXTsRoMfVWU08ZWF1X7QKRRn', { callback: function (results)
        {
          if(results.statusCode == 200) {
            if(d3.select("#bingGeocoderSubmit").classed("glyphicon-search")) {
              $(document).ready(function(){
                $('[data-toggle="tooltip"]').tooltip();   
              });
              document.getElementById("bingGeocoderInput").blur();
              var bbox = results.resourceSets[0].resources[0].bbox,
                first = new L.LatLng(bbox[0], bbox[1]),
                second = new L.LatLng(bbox[2], bbox[3]),
                tmpBounds = new L.LatLngBounds([first, second]);
              this._map.fitBounds(tmpBounds);
              this._map.removeLayer(tmpPoint);
              tmpPoint = new L.marker(results.resourceSets[0].resources[0].point.coordinates);  //.bindPopup(results.resourceSets[0].resources[0].address.formattedAddress);
              this._map.addLayer(tmpPoint);
              d3.select(".leaflet-marker-icon")
                .attr("id","mapIcon")
                .attr("value", results.resourceSets[0].resources[0].name)
                .attr("data-toggle", "tooltip")
                .attr("data-container", "body")
                .attr("data-placement", "auto top")
                .attr("data-html", "true")
                .attr("title", '<p><b><center>' + results.resourceSets[0].resources[0].name + '</center></b></p>');
              d3.select(tmpPoint)
                .on("click", function() { clearSearch(); });
              d3.select("#bingGeocoderSubmit")
                .classed("glyphicon-search", false)
                .classed("glyphicon-remove", true)
                .property("title", "Click to clear search results");
            }
            else {
              clearSearch();
            }
          }
          else {
            d3.select("#bingGeocoderInput").property("value","No matching results");            
          }
        }
      });

     

      //******Clear the results of the geo search
      function clearSearch() {
        map.removeLayer(tmpPoint);
        d3.select(".tooltip").remove();
        d3.select("#bingGeocoderInput").property("value", "");

        d3.select("#bingGeocoderSubmit")
          .classed("glyphicon-remove", false)
          .classed("glyphicon-search", true)
          .style({"background":"", "color":""})
          .property("title", "Click to zoom to specified location");
      }


      //******Make d3 vector layers variables for large map
      var wildSVG = d3.select(map.getPanes().overlayPane).append("svg");
      var wildG = wildSVG.append("g").attr("class", "leaflet-zoom-hide").attr("id", "wildG");



      //******Add topo layer to map
      function addTopo(topo) {
        setArcRadius();

        if(layers.length > 0) {
          removeTopo(layers[layers.length - 1], false);
        }

        var tmpBi = 0;
        layers.some(function(d) {
          if(d.pieClass == topo.pieClass) {
            tmpBi = 1;
          }
          return tmpBi == 1;
        });

        if(tmpBi == 0) {
          layers.push(topo);
        }
       
        var tmpFeats = topo.g.selectAll("." + topo.class)
            .data(topo.features)
          .enter().append("g")
            .attr("value", function(d) { return d.properties.Longitude + "," + d.properties.Latitude; })
            .attr("transform",function(d) { return "translate("+projectPoint([d.properties.Longitude,d.properties.Latitude])+")" })
            .attr("class", "pies " + topo.pieClass);
        
        var pies = tmpFeats.selectAll(".pies")
            .data(function(d) { var tmpPie = pie(d.properties.Data.split(['-'])); tmpPie.forEach(function(obj) { obj.loc = d.properties["General Location"]; obj.data = d.properties.Data.split("-"); }); return tmpPie; })
          .enter().append("g")
            .attr("class", "arc");

        pies.append("path")
          .attr("d", arc) 
          .attr("fill", function(d,i) {return topo.color[i]; })
          .attr("id", function(d,i) {
            if(i > 10 && i == d.data.length - 1) {
              var tmpStr = 'Other';
            }
            else {
              var tmpStr = 'K' + (i + 1);
            }
            return d.loc + '\n<span style="background:' + topo.color[i] + ';">' + tmpStr + ' = ' + d.value + '%</span>'; 
          })
          .on("mouseover", function(data,i) { showIt(this.id, data, i, topo); resizeTooltip(); })
          .on("mousemove", function() { tooltip.style("top", (d3.event.pageY-40) + "px").style("left", (d3.event.pageX+15) + "px"); resizeTooltip(); })
          .on("mouseout", function() { tooltip.style("visibility", "hidden"); });

        d3.select("#curDataLayer")
          .text(topo.title)
          .classed("activeLayer", true);
      }



      //******Add topo layer to legend map
      function addTopoLegend(topo) {
        if(layersLegend.length > 0) {
          removeTopoLegend(layersLegend[layersLegend.length - 1], false);
        }

        var tmpBi = 0;
        layersLegend.some(function(d) {
          if(d.pieClass == topo.pieClass) {
            tmpBi = 1;
          }
          return tmpBi == 1;
        });

        if(tmpBi == 0) {
          layersLegend.push(topo);
        }

        var tmpFeats = topo.g.selectAll("." + topo.class)
            .data(topo.features)
          .enter().append("g")
            .attr("data-pie", function(d) { return d.properties.Population; })
            .attr("value", function(d) { return d.properties.Longitude + "," + d.properties.Latitude; })
            .attr("transform",function(d) { return "translate("+projectPointLegend([d.properties.Longitude,d.properties.Latitude])+")" })
            .attr("class", "pies " + topo.pieClass);
        
        var pies = tmpFeats.selectAll(".pies")
            .data(function(d) { var tmpPie = pie(d.properties.Data.split(['-'])); tmpPie.forEach(function(obj) { obj.loc = d.properties["Population"]; obj.data = d.properties.Data.split("-"); }); return tmpPie; })
          .enter().append("g")
            .attr("class", "arc");

        pies.append("path")
          .attr("d", arcLegend) 
          .attr("fill", function(d,i) {return topo.color[i]; })
          .attr("id", function(d,i) {
            if(i > 10 && i == d.data.length - 1) {
              var tmpStr = 'Other';
            }
            else {
              var tmpStr = 'K' + (i + 1);
            }
            return d.loc + '\n<span style="background:' + topo.color[i] + ';">' + tmpStr + ' = ' + d.value + '%</span>'; 
           })
          .on("mouseover", function(data,i) { showIt(this.id, data, i, topo); resizeTooltip(); })
          .on("mousemove", function() { tooltip.style("top", (d3.event.pageY-40) + "px").style("left", (d3.event.pageX+15) + "px"); resizeTooltip(); })
          .on("mouseout", function() { tooltip.style("visibility", "hidden"); });

        d3.selectAll("." + topo.pieClass)
          .append("g")
          .attr("transform", function(d) { return "translate(-" + (25 + ((d.properties.Population.length - 9)*2)) + ",30)"; })
          .append("text")
          .text(function(d) { return d.properties.Population; });
      }



      //******Remove topo layer from map
      function removeTopo(topo, tmpBool) {
        var tmpBi = 0;
        var tmpLast = false;
        layers.some(function(d,i) {
          if(d.pieClass == topo.pieClass) {
            tmpBi = 1;
            if(tmpBool == true) {
              tmpLast = (i == layers.length - 1) && (i > 0);
              layers.splice(i,1);
            }
            return tmpBi == 1;
          }
        });

        
        d3.selectAll("." + topo.pieClass).remove();
        if(tmpLast == true) {
          addTopo(layers[layers.length - 1]);
        }
        
        if(layers.length == 0) {
          d3.select("#curDataLayer")
          .text("No Data Layers Selected")  
          .classed("activeLayer", false);
        }
      }



      //******Remove topo layer from legend map
      function removeTopoLegend(topo, tmpBool) {
        var tmpBi = 0;
        var tmpLast = false;
        layersLegend.some(function(d,i) {
          if(d.pieClass == topo.pieClass) {
            tmpBi = 1;
            if(tmpBool == true) {
              tmpLast = (i == layersLegend.length - 1) && (i > 0);
              layersLegend.splice(i,1);
            }
            return tmpBi == 1;
          }
        });

        
        d3.selectAll("." + topo.pieClass).remove();
        if(tmpLast == true) {
          addTopoLegend(layersLegend[layersLegend.length - 1]);
        }
      }




      //******Make tooltip for displaying attribute data
      var tooltip = d3.select("body")
        .append("div")
        .attr("id", "d3Tooltip")
        .attr("class", "d3Tooltip");


      function resizeTooltip() {
        var mapRect = document.getElementById("map").getBoundingClientRect();
        var tmpWindows = ["d3Tooltip"];
        
        tmpWindows.forEach(function(win) {
          var winRect = document.getElementById(win).getBoundingClientRect();
          if(winRect.bottom > mapRect.bottom) {
            d3.select("#" + win).style("top", mapRect.height - winRect.height + "px");
          }
          if(winRect.right > mapRect.right) {
            d3.select("#" + win).style("left", mapRect.width - winRect.width + "px");
          }
        });
      }



      //******Make header div
      d3.select("body")
        .append("div")
        .attr("class", "header")
        .style("padding", "3px 0px 3px 15px")
        .style("height", "40px")
        .html('<span class="brand">Southern Brook Trout Explorer</span> <div id="headerLinks"><a title="Click to go to the Ecosheds homepage" href="http://ecosheds.org" target="_blank">SHEDS Home</a></div><div id="printDownload" class="pull-right"><span id="printControl" class="glyphicon glyphicon-print" title="Print current map" onclick="window.print()"></span></div>');



    function makeLayers() {
      //******Make layer controller
      var baseLayers = {"Google Terrain": googleTerrain, "Google Hybrid": googleHybrid, "Google Satellite": googleSatellite, "Google Street": googleStreet, "Bing Hybrid": bingHybrid, "Bing Satellite": bingSatellite, "Bing Street": bingStreet, "USGS Topo": usgsTopo, "State Outlines": states, "None": blank};
      var overlays = {"States": gsStates, "Continental Divide": gsContDiv, "HUC 2 Watersheds": gsHuc2, "HUC 4 Watersheds": gsHuc4, "HUC 6 Watersheds": gsHuc6, "HUC 8 Watersheds": gsHuc8, "HUC 10 Watersheds": gsHuc10, "HUC 12 Watersheds": gsHuc12, "EBTJV Patches": gsBktPatches, "Streams": gsNHDStreams, "Waterbodies": gsNHDWaterbodies};  
      var overlaysData = {"Structure (K=2)": topos.struct.k2, "Structure (K=3)": topos.struct.k3, "Structure (K=4)": topos.struct.k4, "Structure (K=5)": topos.struct.k5, "Structure (K=6)": topos.struct.k6, "Structure (K=7)": topos.struct.k7, "Structure (K=10)": topos.struct.k10, "DAPC (K=2)": topos.dapc.k2, "DAPC (K=3)": topos.dapc.k3, "DAPC (K=4)": topos.dapc.k4, "DAPC (K=5)": topos.dapc.k5, "DAPC (K=6)": topos.dapc.k6, "DAPC (K=7)": topos.dapc.k7, "DAPC (K=10)": topos.dapc.k10, "DAPC (K=15)": topos.dapc.k15, "DAPC (K=20)": topos.dapc.k20, "DAPC (K=25)": topos.dapc.k25};  
      var overlaysHatch = {"Structure Hatchery (K=2)": topos.hatchS.k2, "Structure Hatchery (K=3)": topos.hatchS.k3, "Structure Hatchery (K=4)": topos.hatchS.k4, "Structure Hatchery (K=5)": topos.hatchS.k5, "Structure Hatchery (K=6)": topos.hatchS.k6, "Structure Hatchery (K=7)": topos.hatchS.k7, "Structure Hatchery (K=10)": topos.hatchS.k10, "DAPC Hatchery (K=2)": topos.hatchD.k2, "DAPC Hatchery (K=3)": topos.hatchD.k3, "DAPC Hatchery (K=4)": topos.hatchD.k4, "DAPC Hatchery (K=5)": topos.hatchD.k5, "DAPC Hatchery (K=6)": topos.hatchD.k6, "DAPC Hatchery (K=7)": topos.hatchD.k7, "DAPC Hatchery (K=10)": topos.hatchD.k10, "DAPC Hatchery (K=15)": topos.hatchD.k15, "DAPC Hatchery (K=20)": topos.hatchD.k20, "DAPC Hatchery (K=25)": topos.hatchD.k25};
      var overlaysPlots = {"Structure (K=2)": "noplot", "Structure (K=3)": "noplot", "Structure (K=4)": "noplot", "Structure (K=5)": "noplot", "Structure (K=6)": "noplot", "Structure (K=7)": "noplot", "Structure (K=10)": "noplot", "DAPC (K=2)": "dapc_K2", "DAPC (K=3)": "dapc_K3", "DAPC (K=4)": "dapc_K4", "DAPC (K=5)": "dapc_K5", "DAPC (K=6)": "dapc_K6", "DAPC (K=7)": "dapc_K7", "DAPC (K=10)": "dapc_K10", "DAPC (K=15)": "dapc_K15", "DAPC (K=20)": "dapc_K20", "DAPC (K=25)": "dapc_K25"};
      layerNames = {};
      layerNames.baseLayers = {};
      layerNames.baseLayers.keys = d3.keys(baseLayers);
      layerNames.baseLayers.values = d3.values(baseLayers);
      layerNames.overlays = {};
      layerNames.overlays.keys = d3.keys(overlays);
      layerNames.overlays.values = d3.values(overlays);
      layerNames.overlaysData = {};
      layerNames.overlaysData .keys = d3.keys(overlaysData);
      layerNames.overlaysData .values = d3.values(overlaysData);
      layerNames.overlaysHatch = {};
      layerNames.overlaysHatch.keys = d3.keys(overlaysHatch);
      layerNames.overlaysHatch.values = d3.values(overlaysHatch);
      layerNames.overlaysPlots = {};
      layerNames.overlaysPlots.keys = d3.keys(overlaysPlots);
      layerNames.overlaysPlots.values = d3.values(overlaysPlots);


      //******Make header control div
      d3.select("body")
        .append("div")
        .attr("id", "headerControls")
        .append("div")
        .attr("id", "mapTools")
        .append("div")
        .attr("id", "baselayerSelect")
        .attr("class", "layerList")
        .append("div")
        .attr("id", "baselayerList")
        .attr("class", "filterAttrList layerList")
        .property("title", "Click to change map baselayer")
        .html('<span id="baselayerListHeader">Select Baselayer</span><span class="glyphicon glyphicon-triangle-bottom pull-right"></span>')
        .on("click", function() { if(d3.select("#baselayerListDropdown").style("display") == "none") {d3.select("#baselayerListDropdown").style("display", "inline-block");} else {d3.select("#baselayerListDropdown").style("display", "none");} });;

      d3.select("#baselayerSelect")
        .append("div")
        .attr("id", "baselayerListDropdown")
        .on("mouseleave", function() { d3.select(this).style("display", "none") });

      //******Add baselayer options
      d3.select("#baselayerListDropdown").selectAll("div")
        .data(layerNames.baseLayers.keys)
        .enter()
          .append("div")
          .attr("class", "layerName")
          .text(function(d) { return d; })
          .property("value", function(d,i) { return i; })
          .property("title", function(d) { return d; })
          .on("click", function() { changeBaselayer(this); })
          .append("span")
          .attr("class", "glyphicon glyphicon-ok pull-right activeOverlay")
          .style("visibility", function(d,i) { if(i == 8) {return "visible";} else {return "hidden";} });


      //******Initialize baselayer
      map.addLayer(states);
      var oldBaseLayerIndex = 8;


      //******Function to change baselayer on select change
      function changeBaselayer(tmpDiv) {
        //***Remove old layer
        var layerDivs = d3.select("#baselayerListDropdown").selectAll("div");
        
        layerDivs[0].forEach(function(tmpLayer) {
          if(d3.select(tmpLayer).select("span").style("visibility") == "visible") {
            d3.select(tmpLayer).select("span").style("visibility", "hidden");
            map.removeLayer(layerNames.baseLayers.values[d3.select(tmpLayer).property("value")]);
          }
        });

        //***Add new layer
        d3.select(tmpDiv).select("span").style("visibility", "visible");
        map.addLayer(layerNames.baseLayers.values[tmpDiv.value]);
        layerNames.baseLayers.values[tmpDiv.value].bringToBack();       
      }



      //******Add overlay layer select for hucs, states
      d3.select("#mapTools")
        .append("div")
        .attr("id", "overlaySelect")
        .attr("class", "layerList")
        .append("div")
        .attr("id", "overlayList")
        .attr("class", "filterAttrList layerList")
        .property("title", "Click to select overlay layers to display on map")
        .html('<span id="overlayListHeader">Select Overlay Layers</span><span class="glyphicon glyphicon-triangle-bottom pull-right"></span>')
        .on("click", function() { if(d3.select("#overlayListDropdown").style("display") == "none") {d3.select("#overlayListDropdown").style("display", "inline-block");} else {d3.select("#overlayListDropdown").style("display", "none");} });;

      d3.select("#overlaySelect")
        .append("div")
        .attr("id", "overlayListDropdown")
        .on("mouseleave", function() { d3.select(this).style("display", "none") });

      //******Add overlay options
      d3.select("#overlayListDropdown").selectAll("div")
        .data(layerNames.overlays.keys)
        .enter()
          .append("div")
          .attr("class", "layerName")
          .text(function(d) { return d; })
          .property("value", function(d,i) { return i; })
          .property("title", function(d) { return d; })
          .on("click", function(d,i) { changeOverlay(this, i); })
          .append("span")
          .attr("class", "glyphicon glyphicon-ok pull-right activeOverlay")
          .style("visibility", function(d) { if(d == "Deerfield Watershed") {return "visible";} else {return "hidden";} });

      //******Function to add/remove overlay layer
      function changeOverlay(tmpDiv, i) {
        if(d3.select(tmpDiv).select("span").style("visibility") == "hidden") {
          d3.select(tmpDiv).select("span").style("visibility", "visible");
          map.addLayer(layerNames.overlays.values[tmpDiv.value]);
          if(tmpDiv.title == "EBTJV Patches") {
            d3.select("#gsLegendImg").attr("src", "http://felek.cns.umass.edu:8080/geoserver/wms?REQUEST=GetLegendGraphic&VERSION=1.0.0&FORMAT=image/png&WIDTH=30&HEIGHT=30&LAYER=EBTJV:ebtjv_patches_bkt_09_22_16_southern&SCALE=20000");
            toolWindowToggle("gsLegend");
          }
        } 
        else {
          d3.select(tmpDiv).select("span").style("visibility", "hidden");
          map.removeLayer(layerNames.overlays.values[tmpDiv.value]);
          if(tmpDiv.title == "EBTJV Patches") {
            d3.select("#gsLegendImg").attr("src", "");
            toolWindowToggle("gsLegend");
          }
        }
      }









      //******Add population assignment layer select for structure, dapc
      d3.select("#mapTools")
        .append("div")
        .attr("id", "dataSelect")
        .attr("class", "layerList")
        .append("div")
        .attr("id", "dataList")
        .attr("class", "filterAttrList layerList")
        .property("title", "Click to select population assignment layers to display on map")
        .html('<span id="dataListHeader">Select Data Layers</span><span class="glyphicon glyphicon-triangle-bottom pull-right"></span>')
        .on("click", function() { if(d3.select("#dataListDropdown").style("display") == "none") {d3.select("#dataListDropdown").style("display", "inline-block");} else {d3.select("#dataListDropdown").style("display", "none");} });;

      d3.select("#dataSelect")
        .append("div")
        .attr("id", "dataListDropdown")
        .on("mouseleave", function() { d3.select(this).style("display", "none") });

      //******Add data options
      d3.select("#dataListDropdown").selectAll("div")
        .data(layerNames.overlaysData.keys)
        .enter()
          .append("div")
          .attr("class", "layerName")
          .text(function(d) { return d; })
          .property("value", function(d,i) { return i; })
          .property("title", function(d) { return d; })
          .on("click", function(d,i) { changeOverlayData(this, i); })
          .append("span")
          .attr("class", "glyphicon glyphicon-ok pull-right activeOverlay")
          .style("visibility", function(d) { if(d == "Deerfield Watershed") {return "visible";} else {return "hidden";} });





      //******Function to add/remove overlay layer
      function changeOverlayData(tmpDiv, i) {
        if(d3.select(tmpDiv).select("span").style("visibility") == "hidden") {
          d3.select(tmpDiv).select("span").style("visibility", "visible");
          addTopo(layerNames.overlaysData.values[i]);
          addTopoLegend(layerNames.overlaysHatch.values[i]);
          d3.select("#plotsDiv")
            .append("img")
            .attr("id", "plot_" + i)
            .attr("src", "images/" + layerNames.overlaysPlots.values[i] + ".jpg");
        } 
        else {
          d3.select(tmpDiv).select("span").style("visibility", "hidden");
          removeTopo(layerNames.overlaysData.values[i], true);
          removeTopoLegend(layerNames.overlaysHatch.values[i], true);
          d3.select("#plot_" + i).remove();
        }
      }


 

      //Add panel icons
      d3.select("#headerControls")
        .append("div")
        .attr("id", "panelTools");
        //.style("display", "none");

      var hcPanels = ["legend", "charts"];
      var hcGlyphs = ["glyphicon-check", "glyphicon-stats"];
      var hcLabel = ["Hatcheries", "Plots"]
      d3.select("#panelTools").selectAll("divs")
        .data(hcPanels)
        .enter()
          .append("div")
          .attr("id", function(d) { return "hc" + d.charAt(0).toUpperCase() + d.slice(1) + "Div"; })
          .attr("class", "hcPanelDivs layerList")
          .property("title", function(d,i) { return "Click to show " + hcLabel[i] + " window"; })
          .html(function(d,i) { return '<span id="' + d + 'Span" class="glyphicon ' + hcGlyphs[i] + '"></span><p>' + hcLabel[i] + '</p>'; })
          .on("click", function(d) { if(d != "attrSelect") { return toolWindowToggle(d);} });

      d3.select("#legendSpan").attr("class", "icon-glyphicons-255-fishes");

      d3.select("#hcAttrSelectDiv")
        .attr("data-toggle", "modal")
        .attr("data-target", "#attrSelectModal");

      d3.select("#hcChartsDiv").style("border-right", "1px solid #262c40");




      //******Add in text for which data layer is being displayed
      d3.select("#headerControls")
        .append("div")
        .attr("id", "curDataLayer")
        .text("No Data Layers Selected")
        .property("title", "Current data layer displayed on the map");
              




      //******Add geolocater
      d3.select("#headerControls")
        .append("div")
        .attr("id", "bingGeoLocate")
        .attr("class", "layerList");

      //******Reappend geocoder to bingGeoLocate div
      //bingGeocoder._container.remove();
      //$('#bingGeoLocate').appendChild(bingGeocoder.onAdd(map));
      document.getElementById('bingGeoLocate').appendChild(bingGeocoder.onAdd(map));
      d3.select("#bingGeocoderInput")
        .on("mouseup", function() { if(this.value == "No matching results") { this.value = ""; } else { $(this).select(); } })
        .on("blur", function() { modifySearch(this, "blur"); })
        .on("keyup", function() { modifySearch(this, "key"); }); // if(d3.event.keyCode == 13) { if(d3.select("#bingGeocoderSubmit").classed("glyphicon-remove") == true) { $("#bingGeocoderSubmit").click(); } } });



      function modifySearch(tmpEl, tmpEvent) {
        if(tmpEvent == "blur") {
          if((tmpEl.value == "" || tmpEl.value == "No matching results") && document.getElementById("mapIcon")) { 
            tmpEl.value = d3.select("#mapIcon").attr("value"); 
            d3.select("#bingGeocoderSubmit").classed("glyphicon-remove", true).classed("glyphicon-search", false);
          }
          else if(tmpEl.value == "No matching results" && !document.getElementById("mapIcon")) {
            tmpEl.value = "";
          }
        } 
        else if(document.getElementById("mapIcon")) {
          if(tmpEl.value != d3.select("#mapIcon").attr("value")) {
            d3.select("#bingGeocoderSubmit").classed("glyphicon-remove", false).classed("glyphicon-search", true);
          }
          else {
            d3.select("#bingGeocoderSubmit").classed("glyphicon-remove", true).classed("glyphicon-search", false);
          }
        }
      }
}


      //******Function to close window when image icon is clicked
      function closeIt(tmpWin) {
        var tmpName = tmpWin;
        if (tmpWin == "polFilter") {tmpName = "Geographic Filter";}
        else if (tmpWin == "attributes") {tmpName = "Feature Attributes";}
        else if (tmpWin == "attrSelect") {tmpName = "Attribute Selection";}

        d3.select("#" + tmpWin + "Div").style("display", "none"); 
        d3.select("#" + tmpWin + "Control").property("title", "Click to show " + tmpName + " window");
      }
      




      //******Make splash screen
      d3.select("body")
        .append("div")
        .attr("id","splashScreen")
        .attr("class", "msgBackgroundDiv")
        .append("div")
        .attr("id", "splashScreenDiv")
        .append("p")
        .attr("id", "splashWelcome")
        .html('Welcome to the Deerfield watershed <span style="font-variant:small-caps;color:#b3d9ff;font-size:41px;text-shadow:1px 2px black;">Stream Crossings Explorer</span>');

      d3.select("#splashScreenDiv")
        .append("p")
        .html('This tool helps you locate road-stream crossings based on your interests.')
        .style({"font-size":"29px","margin":"10px 20px 0px"}); 

      d3.select("#splashScreenDiv")
        .append("p")
        .html('To begin, select the crossing, stream and catchment (sub-watershed) attributes that you would like to work with.')
        .style({"font-size":"22px","margin":"0px 10px 20px 20px"});

      d3.select("#splashScreenDiv")
        .append("div")
        .attr("id", "splashGIF")
        .property("title", "Animation showing feature selection based on attribute value specifications")
        .html('<img src="images/sce_demo_2.gif" style="position:relative;left:-11px;width:104%">');

      d3.select("#splashScreenDiv")
        .append("button")
        .attr("id", "splashButton")
        .attr("class", "btn legendBtn")
        .property("title", "Click to continue to tutorial and attribute selection")
        .text("Continue...")
        .on("click", function() { 
          d3.select("#splashScreen").style("display", "none");
          localStorage.setItem('disableSplash', d3.select("#disableSplash").property("checked"));
          if(localStorage.getItem('doneTour') != "yeah!" && disableTutorialSession != true) {
            startIntro();
          }
          else {
            $('#attrSelectModal').modal('show');
          }
        });
          

      d3.select("#splashScreenDiv")
        .append("div")
        .style({"float":"right","position":"relative","top":"-75px","left":"-30px"})
        .append("label")
        .property("title", "Check box to prevent this screen from displaying on future website visits")
        .html('<input type="checkbox" id="disableSplash" style="transform:scale(1.3)">Check to prevent this screen from displaying again</input>');

        







      //*****Make div for downloads
      d3.select("body")
        .append("div")
        .attr("class", "legend gradDown")
        .attr("id", "downloadDiv");

      $('#downloadDiv').draggable({containment: "body", cancel: "input,label,textarea,button,select,option"});

      d3.select("#downloadDiv")
        .append("h4")
        .text("Downloads")
        .attr("class", "legTitle")
        .attr("id", "downloadTitle")
        .append("span")
        .html('<span class="glyphicon glyphicon-info-sign help-tooltip" data-toggle="tooltip" data-container="body" data-placement="auto right" data-html="true" title="<p><u><b><center>Downloads</center></b></u></p><p>Features presently displayed on the map from the crossings, streams, or catchments layer can be saved to a CSV, shapefile, or geoJSON file.</p>"></span>');
 
      d3.select("#downloadTitle")
        .append("span")
        .attr("class", "glyphicon glyphicon-remove pull-right minimize-button")
        .property("title", "Click to hide Downloads window")
        .on("click", function() { toolWindowToggle("download"); });






      //******Make div for legend
      d3.select("body")
        .append("div")
        .attr("class", "legend gradDown")
        .attr("id", "legendDiv");

      $('#legendDiv').draggable({containment: "body", cancel: ".toggle-group,input,textarea,button,select,option"});

      d3.select("#legendDiv")
        .append("h4")
        .text("Hatcheries")
        .attr("class", "legTitle")
        .attr("id", "legendTitle")
        .append("span")
        .html('<span class="glyphicon glyphicon-info-sign help-tooltip" data-toggle="tooltip" data-container="body" data-placement="auto right" data-html="true" title="<p><u><b><center>Hatchery Population Assignment</center></b></u></p><p>Shows the population assignment proportions for each hatchery for the associated top-most layer displayed for the DAPC or Structure results.</p><br><p>For data where K is 10 or greater, a gray slice in the pie chart represents the summed percentage of all populations (K) that were attributed 10% or less by the analysis.</p>"></span>');
 
      d3.select("#legendTitle")
        .append("span")
        .attr("class", "glyphicon glyphicon-remove pull-right minimize-button")
        .property("title", "Click to hide Hatcheries window")
        .on("click", function() { toolWindowToggle("legend"); });

      //***Add map
      d3.select("#legendDiv")
        .append("div")
        .attr("id", "legendMap");

      var legendMap = new L.Map('legendMap', {center: [1.04, 1.01], zoomControl: false, zoom: 13, minZoom: 13, maxZoom: 13, attributionControl: false, dragging: false, doubleClickZoom: false, scrollWheelZoom: false, boxZoom: false, touchZoom: false, keyboard: false});

      //******Make d3 vector layer variable for small map
      var hatchSVG = d3.select(legendMap.getPanes().overlayPane).append("svg");
      var hatchG = hatchSVG.append("g").attr("class", "leaflet-zoom-hide").attr("id", "hatchG");



      //******Make div for geoserver legend
      d3.select("body")
        .append("div")
        .attr("class", "legend gradDown")
        .attr("id", "gsLegendDiv");

      $('#gsLegendDiv').draggable({containment: "body", cancel: ".toggle-group,input,textarea,button,select,option"});

      //***Add map
      d3.select("#gsLegendDiv")
        .append("img")
        .attr("id", "gsLegendImg");
        //.attr("src", "http://felek.cns.umass.edu:8080/geoserver/wms?REQUEST=GetLegendGraphic&VERSION=1.0.0&FORMAT=image/png&WIDTH=30&HEIGHT=30&LAYER=EBTJV:ebtjv_patches_bkt_09_22_16_southern&SCALE=20000");
      




      //******Make div for political filter
      d3.select("body")
        .append("div")
        .attr("class", "legend gradDown")
        .attr("id", "polFilterDiv");

      $('#polFilterDiv').draggable({containment: "body"});

      //******Add political filter heading & glyphs
      d3.select("#polFilterDiv")
        .append("h4")
        .text("Geographic Filter")
        .attr("class", "legTitle")
        .attr("id", "polFilterTitle")
        .append("span")
        .html('<span class="glyphicon glyphicon-info-sign help-tooltip" data-toggle="tooltip" data-placement="auto right" data-container="body"  data-html="true" title="<p><u><b><center>Geographic Filter</center></b></u></p><p>Enables filtering of features in the Crossings, Catchments, and Streams layers to those contained within the selected \'Area\'.</p><br><p>Conditional statements added to the filter from the same \'Class\' act as \'or\' operators (features can be in any of the selected areas), while conditional statements from different classes act as \'and\' operators (features must be in selected areas from all classes)</p>"></span>');

      d3.select("#polFilterTitle")
        .append("span")
        .attr("class", "glyphicon glyphicon-remove pull-right minimize-button")
        .property("title", "Click to hide Geographic Filter window")
        .on("click", function() { toolWindowToggle("polFilter"); });

      //******Add political filter select div
      d3.select("#polFilterDiv")
        .append("div")
        .attr("id", "polFilterSelectDiv");

      //******Add area to contain active filters
      d3.select("#polFilterDiv")
        .append("div")
        .attr("id", "polFilterConditions");






      //******Make div for attribute display
      d3.select("body")
        .append("div")
        .attr("class", "legend gradDown")
        .attr("id", "attributesDiv")
        .style("display", "none");

      $('#attributesDiv').draggable({containment: "body", handle: "h4,table,p"});

      //******Add attribute display heading & glyphs
      d3.select("#attributesDiv")
        .append("h4")
        .text("Feature Attributes")
        .attr("class", "legTitle")
        .attr("id", "attributesTitle")
        .append("span")
        .html('<span class="glyphicon glyphicon-info-sign help-tooltip" data-toggle="tooltip" data-placement="auto right" data-container="body"  data-html="true" title="<p><u><b><center>Feature Attributes</center></b></u></p><p>Click on a Crossing, Stream, or Catchment feature to view its attribute values.<br><br>The user has the choice of either viewing all attributes or only those checked in the \'Select Attributes\' window.</p>"></span>');

      d3.select("#attributesTitle")
        .append("span")
        .attr("class", "glyphicon glyphicon-remove pull-right minimize-button")
        .property("title", "Click to hide Feature Attributes window")
        .on("click", function() { toolWindowToggle("attributes"); });

      //******Add buttons to display either all or selected attribute values
      d3.select("#attributesDiv")
        .append("div")
        .attr("id", "attrShow")
        .append("button")
        .attr("id", "attrShowSel")
        .attr("class", "attrBtn")
        .text("Show Selected")
        .property("title", "Click to view only feature attributes checked in the 'Select Attribute' window")
        .style({"margin-left":"28px"})
        .on("click", function() { styleAttributes(this.id); resizePanels();});

      d3.select("#attrShow")
        .append("button")
        .attr("id", "attrShowAll")
        .attr("class", "attrBtn")
        .text("Show All")
        .property("title", "Click to view all feature attributes")
        //.style("opacity", "0.5")
        .on("click", function() { styleAttributes(this.id); resizePanels();});

      //******Add attribute values div
      d3.select("#attributesDiv")
        .append("div")
        .attr("id", "attValuesDiv")
        .append("p")
        .attr("id", "noAttrText")
        .text("Click on a map feature to show attributes");

      d3.select("#attValuesDiv")
        .append("table")
        .attr("id", "attValuesTable")
        .append("tr")
        .attr("id", "attHeadingsRow")
        .attr("class", "attTRHead");

      //******Add cells to table for attribute and value
      d3.select("#attHeadingsRow")
        .append("th")
        .text("Attribute")
        .attr("class", "attTH");

      d3.select("#attHeadingsRow")
        .append("th")
        .text("Value")
        .attr("class", "attTH");
        



     //******Change styling of attribute table
     function styleAttributes(tmpBut) {
       if(tmpBut == "attrShowSel") {
         d3.select("#attValuesTable").selectAll(".attTR").style("display", "none");
         d3.select("#attValuesTable").selectAll(".attTRVis").style("display", "table-row");         
         d3.select("#attrShowSel")
           .style({"color":"navy", "background": ""})
           .on("mouseover", function() {d3.select(this).style({"color":"navy", "background":""}) })
           .on("mouseout", function() {d3.select(this).style({"color":"navy", "background":""}) });
         d3.select("#attrShowAll")
           .style({"color":"#4d4d4d", "background":"none", "border":"none"})
           .on("mouseover", function() {d3.select(this).style({"color":"green", "background":"white", "border":"1px solid green"}) })
           .on("mouseout", function() {d3.select(this).style({"color":"#4d4d4d", "background":"none", "border":"none"}) });
       }
       else {
         d3.select("#attValuesTable").selectAll(".attTR,.attTRVis").style("display", "table-row");
         d3.select("#attrShowAll")
           .style({"color":"navy", "background": ""})
           .on("mouseover", function() {d3.select(this).style({"color":"navy", "background":""}) })
           .on("mouseout", function() {d3.select(this).style({"color":"navy", "background":""}) });
         d3.select("#attrShowSel")
           .style({"color":"#4d4d4d", "background":"none", "border":"none"})
           .on("mouseover", function() {d3.select(this).style({"color":"green", "background":"white", "border":"1px solid green"}) })
           .on("mouseout", function() {d3.select(this).style({"color":"#4d4d4d", "background":"none", "border":"none"}) });
       }
     }





      //******Make div for attr selection
      d3.select("body")
        .append("div")
        .attr("class", "modal fade ui-draggable in ")
        .attr("id", "attrSelectModal")
        .style("display", "none")
        .on("click", function() { if(localStorage.getItem('doneTour') != "yeah!" && disableTutorialSession != true) {startIntro();} })
        .append("div")
        .attr("class", "modal-dialog modal-lg legend gradDown")
        .attr("id", "attrSelectDiv");
      
      //$('#attrSelectDiv').draggable({containment: "body"});





      //******Make div for histograms (crossfilters)
      d3.select("body")
        .append("div")
        .attr("class", "legend gradDown")
        .attr("id", "chartsDiv");
        //.html('<img class="pull-left header_icon" src="../images/graph_2_small.png" ondblclick="toolWindowToggle(&quot;charts&quot;)" title="Double click to hide charts window"></img>');


      $('#chartsDiv').draggable({containment: "body", cancel: "input,textarea,button,select,option,#charts,.glyphicon"});

      d3.select("#chartsDiv")
        .append("h4")
        .text("Plots")
        .attr("class", "legTitle")
        .attr("id", "filterTitle")
        .append("span")
        .html('<span class="glyphicon glyphicon-info-sign help-tooltip" data-toggle="tooltip" data-placement="auto right" data-container="body"  data-html="true" title="<p><u><b><center>Plots</center></b></u></p><p>Shows a plot of each population\'s location on the first and second PCA axes for the associated data layer displayed on the map.</p>"></span>');

      d3.select("#filterTitle")
        .append("span")
        .attr("class", "glyphicon glyphicon-remove pull-right minimize-button")
        .property("title", "Click to hide Plots window")
        .on("click", function() { toolWindowToggle("charts"); });        

      //*******Add div for viewing plot images
      d3.select("#chartsDiv")
        .append("div")
        .attr("id", "plotsDiv");

/*
        .attr("class", "horBorder")
        .style("background", "#f2f2f2")
        .append("h5")
        .attr("id", "sjTitle")
        .attr("class", "chartsSubTitle")
        .text("Spatial Joins")
        .append("span")
        .html('<span class="glyphicon glyphicon-info-sign help-tooltip" data-toggle="tooltip" data-placement="auto right" data-container="body"  data-html="true" title="<p><u><b><center>Spatial Joins</center></b></u></p><p>When checked, each join shows only features that overlap geographically between its two layers.</p><br><p>Spatial joins enable the filtering of features in one layer based on attribute values of another layer.</p><br><p>For example, to filter for crossings located on second order streams, check the &#39;Crossings & Streams&#39; box, add a chart for the Stream Order attribute from the Streams layer, and click on the &#39;2&#39; column.</p>"></span>');

      d3.select("#sjTitle")
        .append("span")
        .attr("class", "glyphicon glyphicon-triangle-bottom pull-right minimize-button")
        .attr("id", "sjGlyph")
        .attr("data-toggle", "collapse")
        .attr("data-target", "#linkLayers")
        .property("title", "Click to show panel")
        .on("click", function() { changeGlyph(this); });
        
      d3.select("#sjDiv")
        .append("div")
        .attr("id", "linkLayers")
        .attr("class", "collapse")
        .append("hr")
        .attr("class", "legendHR");

        $('#linkLayers').on('shown.bs.collapse', function() {  resizePanels(); });



      //*******Add div for total selections
      d3.select("#chartsDiv")
        .append("div")
        .attr("id", "totalsDiv")
        .attr("class", "horBorder")
        .style("background", "#ccf3ff")
        .append("h5")
        .attr("id", "totalsTitle")
        .attr("class", "chartsSubTitle")
        .text("Selection Counts")
        .append("span")
        .html('<span class="glyphicon glyphicon-info-sign help-tooltip" data-toggle="tooltip" data-placement="auto right" data-container="body"  data-html="true" title="<p><u><b><center>Selection Count</center></b></u></p><p>Displays the count of currently filtered features for each of the Crossings, Catchments, and Streams layers.</p>"></span>');

      d3.select("#totalsTitle")
        .append("span")
        .attr("class", "glyphicon glyphicon-triangle-bottom pull-right minimize-button")
        .attr("id", "totalsGlyph")
        .attr("data-toggle", "collapse")
        .attr("data-target", "#totals")
        .property("title", "Click to show panel")
        .on("click", function() { changeGlyph(this); });

      d3.select("#totalsDiv")
        .append("div")
        .attr("id", "totals")
        .attr("class", "collapse")
        .append("hr")
        .attr("class", "legendHR");

        $('#totals').on('shown.bs.collapse', function() {  resizePanels(); });




      //*******Add div for histograms
      d3.select("#chartsDiv")
        .append("div")
        .attr("id", "graphsDiv")
        .attr("class", "horBorder")
        .append("h5")
        .attr("id", "distributionsTitle")
        .attr("class", "chartsSubTitle")
        .text("Distributions")
        .append("span")
        .html('<span class="glyphicon glyphicon-info-sign help-tooltip" data-toggle="tooltip" data-placement="auto right" data-container="body"  data-html="true" title="<p><u><b><center>Attribute Distributions</center></b></u></p><p>Contains graphs that show value frequency distributions of selected attributes.</p><br><p>Each graph can be restricted to specific value ranges or categories, which in turn filters the associated features displayed on the map.</p>"></span>');

      d3.select("#distributionsTitle")
        .append("span")
        .attr("class", "glyphicon glyphicon-triangle-bottom pull-right minimize-button")
        .attr("id", "distributionsGlyph")
        .attr("data-toggle", "collapse")
        .attr("data-target", "#charts")
        .property("title", "Click to show panel")
        .on("click", function() { changeGlyph(this); });

      d3.select("#graphsDiv")
        .append("div")
        .attr("id", "charts")
        .attr("class", "collapse");

        $('#charts').on('shown.bs.collapse', function() {  resizePanels(); });



      //******Add div with option to Add Chart Data
      d3.select("#chartsDiv")
        .append("div")
        .attr("id", "addChartsDiv")
        .append("button")
        .attr("class", "btn legendBtn")
        .attr("id", "addChartsDivButton")
        .property("title", "Click to open panel for selecting and adding chart data")
        .html('<span class="glyphicon glyphicon-plus-sign btn-glyph"></span><p class="glyphLabel">Add Chart Data</p>')
        .on("click", function() { d3.select("#filterLayers").transition().duration(500).ease("cubic-in-out").style({"display": "block"}); });
        
      //******Add div and table to hold select boxes for adding histograms
      d3.select("#chartsDiv")
        .append("div")
        .attr("id", "filterLayers")
        .append("button")
        .attr("id", "addChartButton")
        .attr("class", "legendBtn chartBtn disabled")
        .property("title", "Select 'Layer' and 'Attribute' to enable addition of chart")
        .property("disabled", true)
        .html('<span id="addChartButtonGlyph" class="glyphicon glyphicon-ok btn-glyph disabled"></span><p class="glyphLabel">Add</p>')
        .on("click", function() { 
          addFilter(d3.select("#attributeFilterSelect").property("value"), topos[d3.select("#attributeFilterSelect").attr("data-layer")]);
          joinMessage("1");
          d3.select("#filterLayers").transition().duration(500).ease("cubic-in-out").style({"display": "none"});
          d3.select("#attributeFilterSelect").property("selectedIndex", 0);
          d3.select("#addChartButton")
            .property("title", "Select 'Layer' and 'Attribute' to enable addition of chart")
            .classed("disabled", true);
          d3.select("#addChartButtonGlyph").classed("disabled", true);
          if(d3.select("#charts").classed("in") == false) {
            $('#charts').collapse('show');
            changeGlyph(document.getElementById("distributionsGlyph"));
          }
          else {
            resizePanels();
          }
        });

      d3.select("#filterLayers")
        .append("button")
        .attr("id", "cancelChartButton")
        .attr("class", "legendBtn chartBtn")
        .property("title", "Click to cancel chart addition")
        .html('<span id="cancelChartButtonGlyph" class="glyphicon glyphicon-remove btn-glyph"></span><p class="glyphLabel">Cancel</p>')
        .on("click", function() { d3.select("#filterLayers").transition().duration(500).ease("cubic-in-out").style({"display": "none"}); });

      d3.select("#filterLayers")
        .append("span")
        .attr("class", "glyphicon glyphicon-triangle-right")
        .attr("id", "addChartTriangle");

      //******Add in spatial join message div
      d3.select("body")
        .append("div")
        .attr("id","joinMessageBackground")
        .attr("class", "msgBackgroundDiv")
        .append("div")
        .attr("id", "joinMessageDiv")
        .append("h4")
        .text("Activate Spatial Joins?")
        .attr("class", "legTitle");

      d3.select("#joinMessageDiv")
        .append("div")
        .attr("id","joinMessageInsideDiv")
        .style({"padding":"10px 15px","border-top":"1px solid gray"})
        .append("p")
        .html('<span style="font-weight:bold;font-size:15px;">You added charts from multiple layers, would you like to turn on the spatial join linking them?<br><br></span><span>Spatial joins enable the filtering of features in one layer based on attribute values of geographically overlapping features of another layer.</span>');

      d3.select("#joinMessageInsideDiv")
        .append("div")
        .attr("id", "joinMessageButtonDiv")
        .append("button")
        .property("title", "Activate spatial joins")
        .text("Yes")
        .on("click", function() { joinMessage("2"); });

      d3.select("#joinMessageButtonDiv")
        .append("button")
        .text("No")
        .property("title", "Do not activate spatial joins")
        .on("click", function() { setJoinMessageValues(); });

      d3.select("#joinMessageInsideDiv")
        .append("div")
        .append("label")
        .html('<input type="checkbox" id="disableJoinMessageSession">Turn off this reminder for the rest of this session</input>');
*/

/*
      d3.select("#joinMessageInsideDiv")
        .append("div")
        .append("label")
        .html('<input type="checkbox" id="disableJoinMessagePermanent">Permanently turn off this reminder</input>');
*/

      


      //******Check to see if graphs are from different layers and if so prompt user to employ spatial join
      function joinMessage(step) {
        if(disableJoinMessageSession != "true" && disableJoinMessagePermanent != "true") {
          var tmpName = [];
          graphs.forEach(function(d) {
            var tmpSplit = d.split("-");
            if(tmpName.indexOf(tmpSplit[0]) == -1) {
              tmpName.push(tmpSplit[0]);
            }
          });
          if(tmpName.length > 1) {
            var tmpBi = 0;
            tmpName.forEach(function(layer1) {
              tmpName.forEach(function(layer2) {
                if(document.getElementById(layer1 + "-" + layer2 + "-check")) {
                  if(d3.select("#" + layer1 + "-" + layer2 + "-check").property("checked") == false) {
                    tmpBi = 1;
                  }
                }
              });
            });

            if(tmpBi == 1 & step == 1) {
              d3.select("#joinMessageBackground").style("display", "flex");
            }
            else if(tmpBi == 1 & step == 2) {
              $('#linkLayers').collapse('show');
              changeGlyph(document.getElementById("sjGlyph"));
              tmpName.forEach(function(layer1) {
                tmpName.forEach(function(layer2) {
                  d3.select("#" + layer1 + "-" + layer2 + "-check").property("checked", true);
                });
              });
              checkLink("featureid", "crossings", true);
              setJoinMessageValues();              
            } 
          }
        }
      }

      function setJoinMessageValues() {
          d3.select("#joinMessageBackground").style("display", "none");
          if(d3.select("#disableJoinMessageSession").property("checked") == true) {
            disableJoinMessageSession = "true";
          }
          else {
            disableJoinMessageSession = "false";
          }
                
          if(d3.select("#disableJoinMessagePermanent").property("checked") == true) {
            localStorage.setItem('disableJoinMessagePermanent', "true");
            disableJoinMessagePermanent = "true";
          }
          else {
            localStorage.setItem('disableJoinMessagePermanent', "false");
            disableJoinMessagePermanent = "false";
          }
      }



      //******Set z-indexes of moveable divs so that clicked one is always on top
      d3.selectAll("#legendDiv,#gsLegendDiv,#polFilterDiv,#attributesDiv,#attrSelectDiv,#chartsDiv,#downloadDiv")
        .on("mousedown", function() { setZ(this); });

      function setZ(tmpWin) {
        if (d3.select("#map").classed("introjs-showElement") == false) {
          d3.selectAll("#legendDiv,#gsLegendDiv,#polFilterDiv,#attributesDiv,#attrSelectDiv,#chartsDiv,#downloadDiv").style("z-index", function() { if(d3.select(this).style("opacity") == 1) {return 1000;} else {return 750;} }); 
          d3.select(tmpWin).style("z-index", 1001);
        }
      }



      //*******Make LOADING div
/*
      d3.select("body")
        .append("div")
        .attr("class", "helpBackground")
        .attr("id", "loadingDiv")
        .append("h1")
        .text("LOADING...")
        .style("font-weight", "bold")
        .attr("id", "loading"); 
*/




      //*******Make Help/information div
      d3.select("body")
        .append("div")
        .attr("class", "modal fade ui-draggable in")
        .attr("id", "helpDiv")
        .style("display", "none")
        .append("div")
        .attr("class", "modal-dialog modal-lg")
        .attr("id", "infoDiv")
        .append("div")
        .attr("class", "legendTitle")
        .text("SHEDS: Stream Crossings Explorer")
        .property("title", "SHEDS: Stream Crossings Explorer informational details")
        .append("span")
        .attr("class", "glyphicon glyphicon-remove pull-right minimize-button")
        .attr("data-toggle", "modal")
        .attr("data-target", "#helpDiv")
        .property("title", "Close help");     
        
      d3.select("#infoDiv")
        .append("div")
        .attr("id", "helpMenu")
        .html('<ul class="nav nav-pills nav-stacked"><li class="active" id="overview" title="Project Overview" onclick="changePill(this)"><a href="#">Project Overview</a></li><li id="usage" title="Performance and Design" onclick="changePill(this)"><a href="#">Performance and Design</a></li><li id="videos" title="Instructional Videos" onclick="changePill(this)"><a href="#">Instructional Videos</a></li><li id="sources" title="Data Sources" onclick="changePill(this)"><a href="#">Data Sources</a></li><li id="appendix" title="Data Appendix" onclick="changePill(this)"><a href="#">Data Appendix</a></li></ul>');

      d3.select("#infoDiv")
        .append("div")
        .attr("id", "helpContent")
        .append("div")
        .attr("class", "helpDivs")
        .attr("id", "help-overview")
        .style("display", "inline-block") 
        .html('<h3>Background</h3>'
           + '<p>The Stream Crossings Explorer (SCE) tool is a data visualization and decision support tool that was developed to assist with locating and prioritizing stream crossings that meet user-defined criteria. SCE conveys information related to aquatic connectivity and ecological aspects of river systems as well as risk of failure of road-stream crossings and associated disruption of emergency services. This tool was designed for state and municipal agencies, local decision-makers, regional planners, conservation organizations, and natural resource managers. It is being piloted in the Deerfield Watershed.</p>'
           + '<p>Data for this tool comes from a variety of sources and was developed in partnership with other efforts, including <a href="http://www.umasscaps.org/" target="_blank">CAPS (Conservation Assessment and Prioritization System)</a> and the <a href="https://streamcontinuity.org/" target="_blank">North Atlantic Aquatic Connectivity Collaborative (NAACC)</a>. Thank you to all who provided data, expertise, and feedback for this tool.</p>'
           + '<h3>Tool Development Team</h3>'
           + '<p><u>University of Massachusetts, Amherst</u></p>'
           + '<ul>'
             + '<li><p>Jason Coombs</p></li>'
             + '<li><p>Scott Jackson</p></li>'
             + '<li><p>Melissa Ocana</p></li>'
           + '</ul>'
           + '<p><u>U.S. Geological Survey</u></p>'
           + '<ul>'
             + '<li><p>Ben Letcher</p></li>'
           + '</ul>'
           + '<p>Questions or comments should be directed to Jason Coombs at <a href="mailto:jcoombs@cns.umass.edu">jcoombs@cns.umass.edu</a>.</p>'
           );

      d3.select("#helpContent")
        .append("div")
        .attr("class", "helpDivs")
        .attr("id", "help-usage")
        .html('<h3>Overview</h3>'
           + '<p> The Stream Crossings Explorer (SCE) tool presents users with the most recent data for crossings, streams, and catchments, and enables them to view, interact, filter, and download that data through an intuitive map-based interface.</p>'
           + '<h3>Optimal Performance Requirements</h3>'
           + '<p>SCE is currently supported on the latest versions of all major web browsers. <a target="_blank" href="https://www.google.com/chrome/">Google Chrome</a> is highly recommended for the best user experience. SCE is not intended for use on mobile devices. Note that SCE is a memory-intensive application. Older computers may have difficulty rendering the interface resulting in sluggish performance. If you run into issues, we recommend closing all other programs and browser tabs to increase available memory.</p>'
           + '<h3>Design and Implementation</h3>'
           + '<p>In order to achieve feature filtering in a highly responsive way, SCE was developed as a client-side web application, which means all computations are performed within the user&apos;s web browser (as opposed to remotely on the web server). The application is comprised of two primary components:</p>'
           + '<ul>'
             + '<li><p><b>Analytics Engine:</b> The <a href="http://square.github.io/crossfilter/" target="_blank">crossfilter.js</a> library provides an extremely fast computational engine that can filter and aggregate large multi-variate datasets in near-real time and all within the user&apos;s web browser.</p></li>'
             + '<li><p><b>Visualization Platform:</b> The <a href="https://d3js.org/" target="_blank">d3.js</a> library is a powerful toolkit for developing interactive visualizations such as charts and maps that can respond to user inputs such as clicking and dragging, and update with great speed and efficiency.</p></li>'
           + '</ul>'
           + '<h3>Software Libraries</h3>'
           + '<p>SCE was developed using the following software libraries:</p>'
           + '<ul>'
             + '<li><p><b><a href="https://nodejs.org/en/" target="_blank">Node.js</a>:</b> Web server runtime environment</p></li>'
             + '<li><p><b><a href="https://expressjs.com/" target="_blank">Express</a>:</b> Web server framework and API</p></li>'
             + '<li><p><b><a href="http://leafletjs.com/" target="_blank">Leaflet</a>:</b> Interactive map framework</p></li>'
             + '<li><p><b><a href="https://d3js.org/" target="_blank">D3.js</a>:</b> Data visualization, mapping and interaction</p></li>'
             + '<li><p><b><a href="https://github.com/topojson/topojson" target="_blank">Topojson.js</a>:</b> Geospatial data format</p></li>'
             + '<li><p><b><a href="https://square.github.io/crossfilter/" target="_blank">Crossfilter.js</a>:</b> Analytics engine</p></li>'
             + '<li><p><b><a href="https://github.com/d3/d3-queue" target="_blank">Queue.js</a>:</b> Asynchronous dataset and file retrieval</p></li>'
             + '<li><p><b><a href="http://getbootstrap.com/" target="_blank">Bootstrap</a>:</b> Front-end framework and styling</p></li>'
             + '<li><p><b><a href="http://colorbrewer2.org/" target="_blank">ColorBrewer</a>:</b> Pre-defined color palettes</p></li>'
           + '</ul>'
           + '<h3>Future Work and Contact Info</h3>'
           + '<p>Development of SCE is currently ongoing and future updates will include updated datasets and greater geographic coverage. If you have any questions, encounter any errors, or are interested in applying SCE to your region, please contact Jason Coombs at <a href="mailto:jcoombs@cns.umass.edu">jcoombs@cns.umass.edu</a>.</p>'
           + '<h3>Tool Version</h3>'
           + '<p>v1.0.0 - 07-25-2017</p>'
           + '<ul><li><p>Initial release</p></li></ul>'
           );

      d3.select("#helpContent")
        .append("div")
        .attr("class", "helpDivs")
        .attr("id", "help-videos")
        .html('<p style="background:red;color:white;"><u>NOTICE:</u> Videos were recorded on the previous version of the app and will be updated soon.</p>'
           + '<h3>Tool Overview</h3>'
           + '<video id="video1" class="video-js vjs-default-skin" controls preload="auto" poster="images/sce_overview.jpg" data-setup="{}"><source src="video/sce_overview.mp4" type="video/mp4"><p class="vjs-no-js">To view this video please enable JavaScript, and consider upgrading to a web browser that <a href="http://videojs.com/html5-video-support/" target="_blank">supports HTML5 video</a></p></video>'
           + '<h3>Filters and Spatial Joins</h3>'
           + '<video id="video2" class="video-js vjs-default-skin" controls preload="auto" poster="images/sce_filtering.jpg" data-setup="{}"><source src="video/sce_filtering.mp4" type="video/mp4"><p class="vjs-no-js">To view this video please enable JavaScript, and consider upgrading to a web browser that <a href="http://videojs.com/html5-video-support/" target="_blank">supports HTML5 video</a></p></video>'
           + '<h3>Case Study Example</h3>'
           + '<video id="video3" class="video-js vjs-default-skin" controls preload="auto" poster="images/sce_scenario.jpg" data-setup="{}"><source src="video/sce_scenario.mp4" type="video/mp4"><p class="vjs-no-js">To view this video please enable JavaScript, and consider upgrading to a web browser that <a href="http://videojs.com/html5-video-support/" target="_blank">supports HTML5 video</a></p></video>'
           );       

      d3.select("#helpContent")
        .append("div")
        .attr("class", "helpDivs")
        .attr("id", "help-sources")
        .html('<h3>Datasets</h3>'
          + '<p>SCE combines data from a number of sources. The following tables list sources for each layer\'s attributes.</p><br>'
          + '<h4>Crossings Layer</h4>'
          + '<table>'
            + '<tr><th>Attribute</th><th>Source</th></tr>'
            + '<tr><td>Assessment Date</td><td><a href="https://streamcontinuity.org/" target="_blank">North Atlantic Aquatic Connectivity Collaborative (NAACC)</a></td></tr>'
            + '<tr><td>Average Affected EMS Delay</td><td><a href="http://people.cs.umass.edu/~sheldon/" target="_blank">Dan Sheldon</a> & <a href="http://rbr.cs.umass.edu/shlomo/" target="_blank">Shlomo Zilberstein</a>, UMass Amherst</td></tr>'
            + '<tr><td>Average EMS Delay</td><td><a href="http://people.cs.umass.edu/~sheldon/" target="_blank">Dan Sheldon</a> & <a href="http://rbr.cs.umass.edu/shlomo/" target="_blank">Shlomo Zilberstein</a>, UMass Amherst</td></tr>'
            + '<tr><td>Coldwater (16&deg;C) Restoration Potential</td><td><a href="http://www.umasscaps.org/" target="_blank">Conservation Assessment and Prioritization System (CAPS)</a></td></tr>'
            + '<tr><td>Coldwater (18&deg;C) Restoration Potential</td><td><a href="http://www.umasscaps.org/" target="_blank">Conservation Assessment and Prioritization System (CAPS)</a></td></tr>'
            + '<tr><td>Coldwater (20&deg;C) Restoration Potential</td><td><a href="http://www.umasscaps.org/" target="_blank">Conservation Assessment and Prioritization System (CAPS)</a></td></tr>'
            + '<tr><td>Connectivity Loss</td><td><a href="http://www.umasscaps.org/" target="_blank">Conservation Assessment and Prioritization System (CAPS)</a></td></tr>'
            + '<tr><td>Connectivity Restoration Potential</td><td><a href="http://www.umasscaps.org/" target="_blank">Conservation Assessment and Prioritization System (CAPS)</a></td></tr>'
            + '<tr><td>Crossing Prioritization</td><td><a href="mailto:sjackson@umass.edu">Scott Jackson</a>, University of Massachusetts Amherst</td></tr>'
            + '<tr><td>Crossing Type</td><td><a href="https://streamcontinuity.org/" target="_blank">North Atlantic Aquatic Connectivity Collaborative (NAACC)</a></td></tr>'
            + '<tr><td>Drainage Area</td><td><a href="mailto:jcoombs@cns.umass.edu">Jason Coombs</a>, University of Massachusetts Amherst</td></tr>'
            + '<tr><td>Geomorphic Risk</td><td><a href="mailto:sjackson@umass.edu">Scott Jackson</a>, University of Massachusetts Amherst</td></tr>'
            + '<tr><td>Hydraulic Risk</td><td><a href="mailto:sjackson@umass.edu">Scott Jackson</a>, University of Massachusetts Amherst</td></tr>'
            + '<tr><td>Ecological Disruption</td><td><a href="mailto:sjackson@umass.edu">Scott Jackson</a>, University of Massachusetts Amherst</td></tr>'
            + '<tr><td>Impassability Score</td><td><a href="https://streamcontinuity.org/" target="_blank">North Atlantic Aquatic Connectivity Collaborative (NAACC)</a></td></tr>'
            + '<tr><td>Maximum EMS Delay</td><td><a href="http://people.cs.umass.edu/~sheldon/" target="_blank">Dan Sheldon</a> & <a href="http://rbr.cs.umass.edu/shlomo/" target="_blank">Shlomo Zilberstein</a>, UMass Amherst</td></tr>'
            + '<tr><td>National Highway System</td><td><a href="http://geo-massdot.opendata.arcgis.com/datasets/road-inventory" target="_blank">Massachusetts Department of Transportation (MassDOT)</a></td></tr>'
            + '<tr><td>Overall EMS Delay</td><td><a href="mailto:sjackson@umass.edu">Scott Jackson</a>, University of Massachusetts Amherst</td></tr>'
            + '<tr><td>Overall Risk</td><td><a href="mailto:sjackson@umass.edu">Scott Jackson</a>, University of Massachusetts Amherst</td></tr>'
            + '<tr><td>Q2 Discharge</td><td><a href="mailto:sbmabee@geo.umass.edu">Steve Mabee</a>, University of Massachusetts Amherst</td></tr>'
            + '<tr><td>Road Jurisdiction</td><td><a href="http://geo-massdot.opendata.arcgis.com/datasets/road-inventory" target="_blank">Massachusetts Department of Transportation (MassDOT)</a></td></tr>'
            + '<tr><td>Stream Length</td><td><a href="mailto:jcoombs@cns.umass.edu">Jason Coombs</a>, University of Massachusetts Amherst</td></tr>'
            + '<tr><td>Stream Slope</td><td><a href="mailto:sbmabee@geo.umass.edu">Steve Mabee</a>, University of Massachusetts Amherst</td></tr>'
            + '<tr><td>Structural Risk</td><td><a href="mailto:sjackson@umass.edu">Scott Jackson</a>, University of Massachusetts Amherst</td></tr>'
            + '<tr><td>Stucture Count</td><td><a href="mailto:jcoombs@cns.umass.edu">Jason Coombs</a>, University of Massachusetts Amherst</td></tr>'
            + '<tr><td>Transportation Vulnerability</td><td><a href="mailto:sjackson@umass.edu">Scott Jackson</a>, University of Massachusetts Amherst</td></tr>'
            + '<tr><td>Unit Stream Power</td><td><a href="mailto:sbmabee@geo.umass.edu">Steve Mabee</a>, University of Massachusetts Amherst</td></tr>'
          + '</table>'
          + '<br>'
          + '<h4>Streams Layer</h4>'
          + '<table>'
            + '<tr><th>Variable</th><th>Source</th></tr>'
            + '<tr><td>Stream Order</td><td><a href="mailto:jcoombs@cns.umass.edu">Jason Coombs</a>, University of Massachusetts Amherst</td></tr>'
            + '<tr><td>Stream Temperature (&deg;C)</td><td><a href="http://ecosheds.org/" target="_blank">Spatial Hydro-Ecological Decision System (SHEDS)</a></td></tr>'
            + '<tr><td>Stream Temperature Resistance</td><td><a href="http://ecosheds.org/" target="_blank">Spatial Hydro-Ecological Decision System (SHEDS)</a></td></tr>'
            + '<tr><td>Trout Habitat Suitability</td><td><a href="http://ecosheds.org/" target="_blank">Spatial Hydro-Ecological Decision System (SHEDS)</a></td></tr>'
          + '</table>'
          + '<br>'
          + '<h4>Catchments Layer</h4>'
          + '<table>'
            + '<tr><th>Variable</th><th>Source</th></tr>'
            + '<tr><td>Agriculture (%)</td><td><a href="https://www.mrlc.gov/nlcd2011.php" target="_blank">National Land Cover Dataset (NLCD) 2011</a></td></tr>'
            + '<tr><td>Catchment Slope (%)</td><td><a href="https://www.mrlc.gov/nlcd2011.php" target="_blank">National Land Cover Dataset (NLCD) 2011</a></td></tr>'
            + '<tr><td>Elevation (M)</td><td><a href="http://www.horizon-systems.com/NHDPlus/NHDPlusV2_data.php" target="_blank">National Hydrography Dataset v2 (NHDPlusV2)</a></td></tr>'
            + '<tr><td>Forest Cover (%)</td><td><a href="https://www.mrlc.gov/nlcd2011.php" target="_blank">National Land Cover Dataset (NLCD) 2011</a></td></tr>'
            + '<tr><td>Impervious Surface (%)</td><td><a href="https://www.mrlc.gov/nlcd2011.php" target="_blank">National Land Cover Dataset (NLCD) 2011</a></td></tr>'
            + '<tr><td>Water Cover (%)</td><td><a href="https://www.fws.gov/wetlands/" target="_blank">Fish & Wildlife Service (FWS) National Wetlands Inventory</a></td></tr>'
          + '</table>'
          + '<br>'
          + '<h4>Regional Filters</h4>'
          + '<table>'
            + '<tr><th>Variable</th><th>Source</th></tr>'
            + '<tr><td>County</td><td><a href="http://www.mass.gov/anf/research-and-tech/it-serv-and-support/application-serv/office-of-geographic-information-massgis/datalayers/counties.html" target="_blank">Massachusetts Office of Geographic Information (MassGIS)</a></td></tr>'
            + '<tr><td>DOT District</td><td><a href="http://geo-massdot.opendata.arcgis.com/datasets/highway-sub-districts" target="_blank">Massachusetts Department of Transportation (MassDOT)</a></td></tr>'
            + '<tr><td>Environmental Justice</td><td><a href="http://www.mass.gov/anf/research-and-tech/it-serv-and-support/application-serv/office-of-geographic-information-massgis/datalayers/cen2010ej.html" target="_blank">Massachusetts Department of Transportation (MassDOT)</a></td></tr>'
            + '<tr><td>HUC 12</td><td><a href="http://www.horizon-systems.com/NHDPlus/NHDPlusV2_data.php" target="_blank">National Hydrography Dataset v2 (NHDPlusV2)</a></td></tr>'
            + '<tr><td>State</td><td><a href="http://www.mass.gov/anf/research-and-tech/it-serv-and-support/application-serv/office-of-geographic-information-massgis/datalayers/outline.html" target="_blank">Massachusetts Office of Geographic Information (MassGIS)</a></td></tr>'
            + '<tr><td>Town</td><td><a href="http://www.mass.gov/anf/research-and-tech/it-serv-and-support/application-serv/office-of-geographic-information-massgis/datalayers/adjacent-states-town-boundaries.html" target="_blank">Massachusetts Office of Geographic Information (MassGIS)</a></td></tr>'
          + '</table>'
          );

      d3.select("#helpContent")
        .append("div")
        .attr("class", "helpDivs")
        .attr("id", "help-appendix")
        .html('<h3>Appendix</h3>'
          + '<p>The following tables contain the shortened attribute name used as field headings in shapefile downloads, along with the attribute\'s definition.</p><br>'
          + '<h4>Crossings Layer</h4>'
          + '<table id="app_crossings">'
            + '<tr><th>Attribute</th><th>Shapefile Name</th><th>Definition</th></tr>'
          + '</table>'
          + '<br>'
          + '<h4>Streams Layer</h4>'
          + '<table id="app_streams">'
            + '<tr><th>Attribute</th><th>Shapefile Name</th><th>Definition</th></tr>'
          + '</table>'
          + '<br>'
          + '<h4>Catchments Layer</h4>'
          + '<table id="app_catchments">'
            + '<tr><th>Attribute</th><th>Shapefile Name</th><th>Definition</th></tr>'
          + '</table>');



       d3.select("#infoDiv")
         .append("div")
         .attr("id", "helpFunding")
         .html('<div id="fundingLeftImg"><a href="http://www.massdot.state.ma.us/" target="_blank"><img id="maDOT" src="images/MassDOT-Formal_Logo.jpg" title="Massachusetts Department of Transportation"></a><a href="https://www.usgs.gov/" target="_blank"><img id="usgs" src="images/logo-usgs.png" title="U.S. Geological Survey"</a></div><div id="fundingRightImg"><a href="https://www.doi.gov/hurricanesandy" target="_blank"><img id="doiLogo" src="images/doi_logo.png" title="Department of the Interior"></a><a href="https://www.fs.fed.us/" target="_blank"><img id="usfs" src="images/shield_color.png" title="U.S. Forest Service"></a></div><p id="funders">This project was funded by the <a href="http://www.massdot.state.ma.us/" target="_blank">Massachusetts Department of Transportation</a><br>and the <a href="https://www.doi.gov/hurricanesandy" target="_blank">Department of the Interior Hurricane Sandy Mitigation Fund</a>.<br><br>Additional support was provided by the <a href="https://www.usgs.gov/" target="_blank">U.S. Geological Survey</a>,<br>the <a href="https://www.fs.fed.us/" target="_blank">U.S. Forest Service</a>, and the <a href="http://www.umass.edu/" target="_blank">University of Massachusetts, Amherst</a>.</p>');



      function changePill(tmpID) {
        d3.select("#helpMenu").selectAll("li").classed("active", false);
        d3.select(tmpID).classed("active", true);
        d3.selectAll(".helpDivs").style("display", "none");
        d3.select("#help-" + tmpID.id).style("display", "inline-block");
      }




      function vidFull(tmpVid) {
        if (videojs(tmpVid).isFullscreen() == false) {
          videojs(tmpVid).requestFullscreen();
        }
        else {
          videojs(tmpVid).exitFullscreen();
        }
      }



      function changeGlyph(tmpEl) {
        var selEl = d3.select("#" + tmpEl.id);
        if (selEl.classed("glyphicon-triangle-top")) {
          selEl.classed("glyphicon-triangle-top", false);
          selEl.classed("glyphicon-triangle-bottom", true);
          tmpEl.title = "Click to display panel";
        }
        else {
          selEl.classed("glyphicon-triangle-bottom", false);
          selEl.classed("glyphicon-triangle-top", true);
          tmpEl.title = "Click to hide panel";
        }
      }




      //******Make variables for d3 topoJSON and TSV data
      var topos = {};  //global topoJSON files variable
      var brush = {};   //global brush variable
      var hist = {};   //global histogram object variable
      var graphs = [];   //global list of current graphs variable
      var layers = [];   //global list of topoJSON map layers
      var layersLegend = [];  //global list of topoJSON legend map layers 
      var color = {};
      var toggleWords = {"legend":"Hatcheries", "attrSelect":"Attribute Selection", "polFilter":"Geographic Filter", "charts":"Plots", "attributes":"Feature Attributes", "download":"Downloads"}
      //var disableJoinMessagePermanent = localStorage.getItem('disableJoinMessagePermanent');  //global variable for not showing spatial join prompt message ever
      //var disableJoinMessageSession = false;  //global variable for not showing spatial join prompt message for rest of session
      //var disableTutorialSession = false;  //global variable for not showing tutorial again on closing select attribute for rest of session
      //var IDs = [];
      //var nodeIDs = [];

      //******Add in custom color pallate for streams
      colorbrewer.streams = {};
      colorbrewer.streams["5"] = ["#081d58","#253494","#225ea8","#1d91c0","#41b6c4"];
      colorbrewer.streams["6"] = ["#081d58","#253494","#225ea8","#1d91c0","#41b6c4", "#7fcdbb"];



      //******Wait for all topoJSON files to load
      queue()
        .defer(d3.json, 'layers/dapc.json')
        .defer(d3.json, 'layers/struct.json')
        .defer(d3.json, 'layers/hatch.json')
        .defer(d3.tsv, 'files/struct_k2.tsv')
        .defer(d3.tsv, 'files/struct_k3.tsv')
        .defer(d3.tsv, 'files/struct_k4.tsv')
        .defer(d3.tsv, 'files/struct_k5.tsv')
        .defer(d3.tsv, 'files/struct_k6.tsv')
        .defer(d3.tsv, 'files/struct_k7.tsv')
        .defer(d3.tsv, 'files/struct_k10.tsv')
        .defer(d3.tsv, 'files/struct_k2_hatch.tsv')
        .defer(d3.tsv, 'files/struct_k3_hatch.tsv')
        .defer(d3.tsv, 'files/struct_k4_hatch.tsv')
        .defer(d3.tsv, 'files/struct_k5_hatch.tsv')
        .defer(d3.tsv, 'files/struct_k6_hatch.tsv')
        .defer(d3.tsv, 'files/struct_k7_hatch.tsv')
        .defer(d3.tsv, 'files/struct_k10_hatch.tsv')
        .defer(d3.tsv, 'files/dapc_k2.tsv')
        .defer(d3.tsv, 'files/dapc_k3.tsv')
        .defer(d3.tsv, 'files/dapc_k4.tsv')
        .defer(d3.tsv, 'files/dapc_k5.tsv')
        .defer(d3.tsv, 'files/dapc_k6.tsv')
        .defer(d3.tsv, 'files/dapc_k7.tsv')
        .defer(d3.tsv, 'files/dapc_k10.tsv')
        .defer(d3.tsv, 'files/dapc_k15.tsv')
        .defer(d3.tsv, 'files/dapc_k20.tsv')
        .defer(d3.tsv, 'files/dapc_k25.tsv')
        .defer(d3.tsv, 'files/dapc_k2_hatch.tsv')
        .defer(d3.tsv, 'files/dapc_k3_hatch.tsv')
        .defer(d3.tsv, 'files/dapc_k4_hatch.tsv')
        .defer(d3.tsv, 'files/dapc_k5_hatch.tsv')
        .defer(d3.tsv, 'files/dapc_k6_hatch.tsv')
        .defer(d3.tsv, 'files/dapc_k7_hatch.tsv')
        .defer(d3.tsv, 'files/dapc_k10_hatch.tsv')
        .defer(d3.tsv, 'files/dapc_k15_hatch.tsv')
        .defer(d3.tsv, 'files/dapc_k20_hatch.tsv')
        .defer(d3.tsv, 'files/dapc_k25_hatch.tsv')
        .await(displayIt);







      //******Bind topoJSON data
      function displayIt(error, dapc,struct,hatch,sK2,sK3,sK4,sK5,sK6,sK7,sK10,shK2,shK3,shK4,shK5,shK6,shK7,shK10,dK2,dK3,dK4,dK5,dK6,dK7,dK10,dK15,dK20,dK25,dhK2,dhK3,dhK4,dhK5,dhK6,dhK7,dhK10,dhK15,dhK20,dhK25) {
        topos.struct = {};
        topos.struct.k2 = topojson.feature(struct, struct.objects.struct);
        topos.struct.k3 = topojson.feature(struct, struct.objects.struct);
        topos.struct.k4 = topojson.feature(struct, struct.objects.struct);
        topos.struct.k5 = topojson.feature(struct, struct.objects.struct);
        topos.struct.k6 = topojson.feature(struct, struct.objects.struct);
        topos.struct.k7 = topojson.feature(struct, struct.objects.struct);
        topos.struct.k10 = topojson.feature(struct, struct.objects.struct);

        topos.dapc = {};
        topos.dapc.k2 = topojson.feature(dapc, dapc.objects.dapc);
        topos.dapc.k3 = topojson.feature(dapc, dapc.objects.dapc);
        topos.dapc.k4 = topojson.feature(dapc, dapc.objects.dapc);
        topos.dapc.k5 = topojson.feature(dapc, dapc.objects.dapc);
        topos.dapc.k6 = topojson.feature(dapc, dapc.objects.dapc);
        topos.dapc.k7 = topojson.feature(dapc, dapc.objects.dapc);
        topos.dapc.k10 = topojson.feature(dapc, dapc.objects.dapc);
        topos.dapc.k15 = topojson.feature(dapc, dapc.objects.dapc);
        topos.dapc.k20 = topojson.feature(dapc, dapc.objects.dapc);
        topos.dapc.k25 = topojson.feature(dapc, dapc.objects.dapc);

        topos.hatchS = {};
        topos.hatchS.k2 = topojson.feature(hatch, hatch.objects.hatch);
        topos.hatchS.k3 = topojson.feature(hatch, hatch.objects.hatch);
        topos.hatchS.k4 = topojson.feature(hatch, hatch.objects.hatch);
        topos.hatchS.k5 = topojson.feature(hatch, hatch.objects.hatch);
        topos.hatchS.k6 = topojson.feature(hatch, hatch.objects.hatch);
        topos.hatchS.k7 = topojson.feature(hatch, hatch.objects.hatch);
        topos.hatchS.k10 = topojson.feature(hatch, hatch.objects.hatch);

        topos.hatchD = {};
        topos.hatchD.k2 = topojson.feature(hatch, hatch.objects.hatch);
        topos.hatchD.k3 = topojson.feature(hatch, hatch.objects.hatch);
        topos.hatchD.k4 = topojson.feature(hatch, hatch.objects.hatch);
        topos.hatchD.k5 = topojson.feature(hatch, hatch.objects.hatch);
        topos.hatchD.k6 = topojson.feature(hatch, hatch.objects.hatch);
        topos.hatchD.k7 = topojson.feature(hatch, hatch.objects.hatch);
        topos.hatchD.k10 = topojson.feature(hatch, hatch.objects.hatch);
        topos.hatchD.k15 = topojson.feature(hatch, hatch.objects.hatch);
        topos.hatchD.k20 = topojson.feature(hatch, hatch.objects.hatch);
        topos.hatchD.k25 = topojson.feature(hatch, hatch.objects.hatch);

        color.struct = {};
        color.struct.k2 = ['#5ce600','#e200f2'];
        color.struct.k3 = ['#5ce600','#40a6ff','#e200f2'];
        color.struct.k4 = ['#5ce600','#ff4040','#40a6ff','#e200f2'];
        color.struct.k5 = ['#5ce600','#ff4040','#becc00','#40a6ff','#e200f2']; 
        color.struct.k6 = ['#5ce600','#ff4040','#becc00','#40a6ff','#6600ff','#e200f2']; 
        color.struct.k7 = ['#5ce600','#ff4040','#bf9900','#becc00','#40a6ff','#6600ff','#e200f2']; 
        color.struct.k10 = ['#5ce600','#39e695','#ff4040','#b23000','#bf9900','#becc00','#f200a2','#40a6ff','#6600ff','#e200f2','#bfbfbf'];
        color.struct.k15 = ['#5ce600','#39e695','#00b3a7','#ff4040','#b23000','#bf9900','#ccc999','#becc00','#448000','#f200a2','#cc99bb','#40a6ff','#0047b3','#6600ff','#e200f2','#bfbfbf'];
        color.struct.k20 = ['#5ce600','#39e695','#00b3a7','#bffffb','#ff4040','#b23000','#bf6600','#bf9900','#ccc999','#becc00','#448000','#f200a2','#cc99bb','#b22d50','#40a6ff','#0047b3','#a3aad9','#6600ff','#ba79f2','#e200f2','#bfbfbf'];
        color.struct.k25 = ['#5ce600','#39e695','#00b3a7','#bffffb','#1a6166','#ff4040','#b23000','#ffa280','#bf6600','#bf9900','#ccc999','#becc00','#3d4d00','#448000','#f200a2','#800055','#cc99bb','#b22d50','#40a6ff','#0047b3','#00138c','#a3aad9','#6600ff','#ba79f2','#e200f2','#bfbfbf'];

        color.dapc = {};
        color.dapc.k2 = ["#A6CEE3","#B15928"];
        color.dapc.k3 = ["#A6CEE3","#F06C45","#B15928"];
        color.dapc.k4 = ["#A6CEE3","#B89B74","#ED8F47","#B15928"];
        color.dapc.k5 = ["#A6CEE3","#52AF43","#F06C45","#B294C7","#B15928"];
        color.dapc.k6 = ["#A6CEE3","#98D277","#F16667","#FE982C","#7D54A5","#B15928"];
        color.dapc.k7 = ["#A6CEE3","#99CD91","#B89B74","#F06C45","#ED8F47","#825D99","#B15928"];
        color.dapc.k10 = ["#A6CEE3","#3F8EAA","#79C360","#B89B74","#E52829","#FDB762","#ED8F47","#9471B4","#DDD399","#B15928","#bfbfbf"];
        color.dapc.k15 = ["#A6CEE3","#3B8ABE","#72B29C","#84C868","#4F9F3B","#EC9A91","#E93E3F","#F06C45","#FDAC4F","#FB820F","#D1AAB7","#8C66AF","#A99099","#EEDB80","#B15928","#bfbfbf"];
        color.dapc.k20 = ["#A6CEE3","#579CC7","#EB494A","#8BC395","#89CB6C","#40A635","#919D5F","#F99392","#3688AD","#E83C2D","#F79C5D","#FDA746","#FE8205","#E39970","#BFA5CF","#8861AC","#917099","#E7E099","#DEB969","#B15928","#bfbfbf"];
        color.dapc.k25 = ["#A6CEE3","#68A6CD","#2A7FB7","#569EA4","#99CD91","#8CCC6E","#52AF43","#5C9E42","#B89B74","#F88A89","#ED4F50","#E4201F","#F06C45","#FBB86B","#FDA440","#FE870D","#ED8F47","#D5A7A9","#B294C7","#865FAB","#825D99","#C7B699","#F8F18F","#D4A55B","#B15928","#bfbfbf"];

        //******Add properties to topos and push layer (class name, SVG g object, unique identifier short_heading, colorbrewer class)
        addProps("struct", "k2", wildG, "ID", "sK2", color.struct.k2);
        addProps("struct", "k3", wildG, "ID", "sK3", color.struct.k3);
        addProps("struct", "k4", wildG, "ID", "sK4", color.struct.k4);
        addProps("struct", "k5", wildG, "ID", "sK5", color.struct.k5);
        addProps("struct", "k6", wildG, "ID", "sK6", color.struct.k6);
        addProps("struct", "k7", wildG, "ID", "sK7", color.struct.k7);
        addProps("struct", "k10", wildG, "ID", "sK10", color.struct.k10);

        addProps("dapc", "k2", wildG, "ID", "dK2", color.dapc.k2);
        addProps("dapc", "k3", wildG, "ID", "dK3", color.dapc.k3);
        addProps("dapc", "k4", wildG, "ID", "dK4", color.dapc.k4);
        addProps("dapc", "k5", wildG, "ID", "dK5", color.dapc.k5);
        addProps("dapc", "k6", wildG, "ID", "dK6", color.dapc.k6);
        addProps("dapc", "k7", wildG, "ID", "dK7", color.dapc.k7);
        addProps("dapc", "k10", wildG, "ID", "dK10", color.dapc.k10);
        addProps("dapc", "k15", wildG, "ID", "dK15", color.dapc.k15);
        addProps("dapc", "k20", wildG, "ID", "dK20", color.dapc.k20);
        addProps("dapc", "k25", wildG, "ID", "dK25", color.dapc.k25);

        addProps("hatchS", "k2", hatchG, "ID", "shK2", color.struct.k2);
        addProps("hatchS", "k3", hatchG, "ID", "shK3", color.struct.k3);
        addProps("hatchS", "k4", hatchG, "ID", "shK4", color.struct.k4);
        addProps("hatchS", "k5", hatchG, "ID", "shK5", color.struct.k5);
        addProps("hatchS", "k6", hatchG, "ID", "shK6", color.struct.k6);
        addProps("hatchS", "k7", hatchG, "ID", "shK7", color.struct.k7);
        addProps("hatchS", "k10", hatchG, "ID", "shK10", color.struct.k10);

	addProps("hatchD", "k2", hatchG, "ID", "dhK2", color.dapc.k2);
	addProps("hatchD", "k3", hatchG, "ID", "dhK3", color.dapc.k3);
	addProps("hatchD", "k4", hatchG, "ID", "dhK4", color.dapc.k4);
	addProps("hatchD", "k5", hatchG, "ID", "dhK5", color.dapc.k5);
	addProps("hatchD", "k6", hatchG, "ID", "dhK6", color.dapc.k6);
	addProps("hatchD", "k7", hatchG, "ID", "dhK7", color.dapc.k7);
	addProps("hatchD", "k10", hatchG, "ID", "dhK10", color.dapc.k10);
	addProps("hatchD", "k15", hatchG, "ID", "dhK15", color.dapc.k15);
	addProps("hatchD", "k20", hatchG, "ID", "dhK20", color.dapc.k20);
	addProps("hatchD", "k25", hatchG, "ID", "dhK25", color.dapc.k25);

        //******Add covariate TSV files to topojson
        readTSV(sK2, topos.struct.k2);
        readTSV(sK3, topos.struct.k3);
        readTSV(sK4, topos.struct.k4);
        readTSV(sK5, topos.struct.k5);
        readTSV(sK6, topos.struct.k6);
        readTSV(sK7, topos.struct.k7);
        readTSV(sK10, topos.struct.k10);

        readTSV(dK2, topos.dapc.k2);
        readTSV(dK3, topos.dapc.k3);
        readTSV(dK4, topos.dapc.k4);
        readTSV(dK5, topos.dapc.k5);
        readTSV(dK6, topos.dapc.k6);
        readTSV(dK7, topos.dapc.k7);
        readTSV(dK10, topos.dapc.k10);
        readTSV(dK15, topos.dapc.k15);
        readTSV(dK20, topos.dapc.k20);
        readTSV(dK25, topos.dapc.k25);

        readTSV(shK2, topos.hatchS.k2);
        readTSV(shK3, topos.hatchS.k3);
        readTSV(shK4, topos.hatchS.k4);
        readTSV(shK5, topos.hatchS.k5);
        readTSV(shK6, topos.hatchS.k6);
        readTSV(shK7, topos.hatchS.k7);
        readTSV(shK10, topos.hatchS.k10);

        readTSV(dhK2, topos.hatchD.k2);
        readTSV(dhK3, topos.hatchD.k3);
        readTSV(dhK4, topos.hatchD.k4);
        readTSV(dhK5, topos.hatchD.k5);
        readTSV(dhK6, topos.hatchD.k6);
        readTSV(dhK7, topos.hatchD.k7);
        readTSV(dhK10, topos.hatchD.k10);
        readTSV(dhK15, topos.hatchD.k15);
        readTSV(dhK20, topos.hatchD.k20);
        readTSV(dhK25, topos.hatchD.k25);

        //******Add layer dropdowns
        makeLayers();
        
/*
        //******Read in political featureids
        topos.political = {};
        [crossPol,streamPol,catchPol].forEach(function(tmpPol, i) {
          topos.political[layers[i]] = strToNum(tmpPol);
        });        

        //******Add covariate title and description information
        var tmpLayers = ["crossings", "streams", "catchments", "political"];
        tmpLayers.forEach(function(d) {
          topos[d]["title"] = {};
          topos[d]["title"]["unique_id"] = "Unique ID";
          topos[d]["title"]["featureid"] = "Catchment ID";
          topos[d]["tooltip"] = {};
          topos[d]["cfGroup"] = {};
          topos[d]["unit"] = {};
          topos[d]["direction"] = {};
          topos[d]["data_type"] = {};
          topos[d]["scale"] = {};
          topos[d]["display"] = {};
          topos[d]["rank"] = {};
          topos[d]["conversion"] = {};
          topos[d]["minVal"] = {};
          topos[d]["maxVal"] = {};
          topos[d]["minClip"] = {};
          topos[d]["maxClip"] = {};
          topos[d]["max"] = {};
          topos[d]["catFilter"] = {};
        });

        covInfo.forEach(function(d) {
          topos[d.layer]["title"][d.short_heading] = d.long_heading;
          topos[d.layer]["tooltip"][d.short_heading] = d.tooltip;
          topos[d.layer]["cfGroup"][d.short_heading] = d.cfGroup;
          topos[d.layer]["unit"][d.short_heading] = d.unit;
          topos[d.layer]["direction"][d.short_heading] = d.direction;
          topos[d.layer]["data_type"][d.short_heading] = d.data_type;
          topos[d.layer]["scale"][d.short_heading] = d.scale;
          topos[d.layer]["display"][d.short_heading] = d.display;
          topos[d.layer]["rank"][d.short_heading] = d.rank;
          topos[d.layer]["conversion"][d.short_heading] = {};
          if (jQuery.isEmptyObject(d.conversion) == false) {
            topos[d.layer]["conversion"][d.short_heading] = JSON.parse(d.conversion);
          }
          topos[d.layer]["conversion"][d.short_heading]["raw"] = d.conversion;
        });

  topos.crossings.title = {};
  topos.crossings.title.K1 = "K1";
  topos.crossings.tooltip = {};
  topos.crossings.tooltip.K1 = "Pop 1 Assignment Probability";
  topos.crossings.unit = {};
  topos.crossings.unit.K1 = "";
  topos.crossings.scale = {};
  topos.crossings.scale.K1 = "linear";
  topos.crossings.direction = {};
  topos.crossings.direction.K1 = "forward";
  topos.crossings.data_type = {};
  topos.crossings.data_type.K1 = "decimal";


        //******Get crossfilter groups
        tmpLayers.forEach(function(layer) {
          try {
            topos[layer].cfGroup.all = Array.from(new Set(d3.values(topos[layer].cfGroup))).filter(function(d) { return d != "both"; });
          }
          //for Internet Explorer
          catch (err) {
            topos[layer].cfGroup.all = Object.keys(d3.set(d3.values(topos[layer].cfGroup))._);
          }
        });

        //******Get all keys for covariate data
        var cov = [crossCov, streamCov, catchCov, crossPol];
        tmpLayers.forEach(function(layer, i) {
          topos[layer].keys = d3.keys(cov[i][0]);
        });

        //******Get cfGroup keys for covariate data and make filter object
        layers.forEach(function(layer, i) {
          topos[layer].cfGroup.all.forEach(function(group) {
            topos[layer][group] = {};
            topos[layer][group].filter = {};
            topos[layer][group].keys = d3.keys(cov[i][0]).filter(function(key) { return topos[layer].cfGroup[key] == group || topos[layer].cfGroup[key] == "both"; });
          });
        });

        //******Put keys in rank order
        layers.forEach(function(layer) {
          topos[layer].cfGroup.all.forEach(function(group) {
            var tmpRank = [];
            topos[layer][group].keys.forEach(function(d) {
              tmpRank.push([parseInt(topos[layer].rank[d]), d]);
            });
          
            tmpRank.sort(sortFunction);
            var keyArray = tmpRank.map(function(d) { return d[1]; });
            topos[layer][group].keys = keyArray;
          });

          var tmpRank = [];
          topos[layer].keys.forEach(function(d) {
            tmpRank.push([parseInt(topos[layer].rank[d]), d]);
          });
          
          tmpRank.sort(sortFunction);
          var keyArray = tmpRank.map(function(d) { return d[1]; });
          topos[layer].keys = keyArray;
        });
 
        function sortFunction(a, b) {
          if (a[0] === b[0]) {
            return 0;
          }
          else {
            return (a[0] < b[0]) ? -1 : 1;
          }
        }

        //******Transform covariate data if necessary
        layers.forEach(function(layer,i) {
          topos[layer].cfGroup.all.forEach(function(group) {
            topos[layer][group].keys.forEach(function(key) {
              var tmpMax = d3.max(cov[i], function(data) {return data[key];});
              topos[layer]["max"][key] = tmpMax;
              //topos[layer]["min"][key] = d3.min(cov[i], function(data) { if(data[key] != -9999) {return data[key];} });
              cov[i].forEach(function(row) {
                switch(topos[layer]["scale"][key]) {
                  case "log":
                    if (row[key] != -9999) {
                      row[key] = Math.log(row[key] + 0.1);
                    }
                    break;
                  case "log_rec":
                    if (row[key] != -9999) {
                      row[key] = -(Math.log(tmpMax + 0.1 - row[key]));
                    }
                }
              });
            });
          });
        });

        //******Make crossfilter dimensions for crossings, streams, and catchments
        layers.forEach(function(layer, i) {
          cfDimension(topos[layer], cov[i]);
        });


        //******Make crossfilter dimensions for political
        [crossPol,streamPol,catchPol].forEach(function(tmpPol, i) {
          var topo = topos.political[layers[i]];
          var tmpCF = crossfilter(topo);
          topo.filter = {};
          topo.filter.all = tmpCF.groupAll();

          topos.political.keys.forEach(function(key) {
            topo.filter[key] = tmpCF.dimension(function(d) { return d[key]; } );
            topo.filter[key + "s"] = topo.filter[key].group();
          });
        });


        //******Release covariate data
        crossingCov = crossCov;  //keep to add weighted ROF covariates to
        [crossingData, streamData, catchData, crossCov, streamCov, catchCov, crossPol, streamPol, catchPol, covInfo].forEach(function(d) {
          delete d;
        });
*/

        //******Set d3 map data
        bounds = d3.geo.bounds(topos.struct.k4);

        bounds[0].forEach(function(d,i) {bounds[0][i] = d - 1; });
        bounds[1].forEach(function(d,i) { bounds[1][i] = d + 1; });

        boundsLegend = d3.geo.bounds(topos.hatchS.k4);
        boundsLegend[0].forEach(function(d,i) { boundsLegend[0][i] = d - 0.1; });
        boundsLegend[1].forEach(function(d,i) { boundsLegend[1][i] = d + 0.02; });

        path = d3.geo.path()
          .projection(projectPoint);
          //.pointRadius(3.5);

        pathLegend = d3.geo.path()
          .projection(projectPointLegend);

        //radius = map.getZoom() - 2;

        pie = d3.layout.pie()
          .sort(null)
          .value(function(d) { return d; });

        arc = d3.svg.arc()
          .innerRadius(0)
          .outerRadius(map.getZoom() - 2);

        arcLegend = d3.svg.arc()
          .innerRadius(0)
          .outerRadius(17);


        //color = ["#A6CEE3", "#B89B74", "#ED8F47", "#B15928"];

/*
        //******Add drop down box to select crossing attribute for styling
        addLegend(topos.crossings);
        addLegend(topos.streams);
        addLegend(topos.catchments);

        //******Add button to legend panel to open attribute select panel
        d3.select("#legendDiv")
          .append("button")
          .attr("class", "btn legendBtn")
          .attr("data-toggle", "modal")
          .attr("data-target", "#attrSelectModal")
          .text("Select Attributes");


        //******Add drop down box to select political filter class and type for filtering
        addPolFilters(topos.political);

        //******Add drop down box to select attributes for filtering
        addFilterLayers(layers);

        //******Add the pair-wise links to the spatial join div
        addCFLinks(layers);

        //******Add in attribute appendix data to help div
        addAppendix();
*/
        //******Add topoJSON layers
        //map.addLayer(crossTogSVG);
        //map.addLayer(streamTogSVG);
        //map.addLayer(catchTogSVG); 
        //removeTopo(topos.catchments);
/*
        //******Finalize the attribute selection window
        completeAttrSelect();

        //******Finalize the download window
        completeDownload(layers);

        //******Set catchments layer to "..."
        d3.select("#catchmentsSelect").property("selectedIndex", function() {return 0;});
        changeStyle("...", topos.catchments);  
*/
        //******Set map view
        map.on("viewreset", reset);
        reset();
        resetLegend();

/*
        //******Remove "Loading..." text
        d3.select("#loadingDiv").style("display", "none");

        //******Display Layers window
        toolWindowToggle("legend");

        //******Run splash and intro for first time users
        d3.select("#disableSplash").property("checked", function() { if(localStorage.getItem('disableSplash') == "true") { return true; } else { return false; } });
        if(localStorage.getItem('disableSplash') != "true") {
          d3.select("#splashScreen").style("display","flex");
        }
        else if(localStorage.getItem('doneTour') != 'yeah!') {
          startIntro();
        }
*/
      }




      //******Function to add appendix data
      function addAppendix() {
        layers.forEach(function(layer) {
          topos[layer].keys.forEach(function(key) {
            d3.select("#app_" + layer)
              .append("tr")
              .html('<td>' + topos[layer].title[key] + '</td><td>' + key.slice(0,10) + '</td><td>' + topos[layer].tooltip[key] + '</td>');
          });
        });
      }


      //******Function to toggle tool windows
      function toolWindowToggle(tmpDiv) {
        if (d3.select("#" + tmpDiv + "Div").style("opacity") == "1") {
          d3.select("#" + tmpDiv + "Div").transition().style({"opacity":"0", "visibility":"hidden"});
          d3.select("#hc" + tmpDiv.charAt(0).toUpperCase() + tmpDiv.slice(1) + "Div").property("title", "Click to show " + toggleWords[tmpDiv] + " window");
          
        }
        else {
          d3.select("#" + tmpDiv + "Div").transition().duration(500).ease("cubic").style({"opacity":"1", "display":"block", "visibility":"visible"});            
          d3.select("#hc" + tmpDiv.charAt(0).toUpperCase() + tmpDiv.slice(1) + "Div").property("title", "Click to hide " + toggleWords[tmpDiv] + " window");
          setZ(d3.select("#" + tmpDiv + "Div")[0][0]);
          if (tmpDiv == "legend") {
            setTimeout(function() {
              d3.select("#legendMap").style("display", "block");
              legendMap.invalidateSize();
            }, 500);
          }
        }
      }




      //******Add attribute names and values to table
      function getAttributes(tmpFeat, topo, opacity) {
        if (opacity == 0) {return;}

        d3.select("#noAttrText").style("display", "none");
        d3.select("#attValuesTable").style("display", "table");

        var tmpArray = topo.keys.map(function(d) { return {"att": d, val: formatAtt(topo, d, tmpFeat[d]) }; } );
        var columns = ["att", "val"]

        var rows = d3.select("#attValuesTable").selectAll('.attTR, .attTRVis')
          .data(tmpArray);
        rows.exit().remove();
        rows.enter()
          .append('tr');
        rows
          .attr("class", function(d) { if(topo.display[d.att] == "yes") { return "attTRVis"; } else { return "attTR"; } })
          .property("value", function(d) { return d.att; });          

        var cells = rows.selectAll("td")
          .data(function(row) {
            return columns.map(function (column) {
              return {column: column, value: row[column]};
            });
          });
        cells.enter()
            .append('td')
            .attr("class", "attTD");
        cells
          .text(function(d) { if (d.column == "att") {return formatTitle(topo, d.value);} else {return d.value;} })
          .property("title", function(d) {if (d.column == "att") {return topo.tooltip[d.value];} else {return d.value;} });

        //******Style window
        d3.select("#attrShow").style("display", "block"); 
        if(d3.select("#attrShowSel").style("background-color") != "rgba(0, 0, 0, 0)") {
          styleAttributes("attrShowSel");
        }
        else {
          styleAttributes("attrShowAll");
        }

        if(d3.select("#attributesDiv").style("opacity") == "0") { toolWindowToggle("attributes"); }
      }



      function updateAttributes() {
        var tmpChk = d3.select("#attrSelectDiv").selectAll("input").filter(function() {return d3.select(this).classed("allCheck") == false && this.checked;})[0];
        var tmpChkVals = tmpChk.map(function(chk) {return chk.value;});
        
        d3.select("#attValuesTable").selectAll(".attTR,.attTRVis")
          .attr("class", function() { if(tmpChkVals.indexOf(this.value) == -1) {return "attTR";} else {return "attTRVis";} });
        
        if(d3.select("#attrShowSel").style("opacity") == 1) {
          styleAttributes("attrShowSel");
        } 
        else {
          styleAttributes("attrShowAll");
        }
      }




      //******Format title and units
      function formatTitle(topo, att) {
        if (topo.unit[att]) {
          return topo.title[att]  + " (" + topo.unit[att] + ")";
        }
        else {
          return topo.title[att];
        }
      }


      //******Format data by its data_type
      function formatAtt(topo, att, val) {
        switch (topo.data_type[att]) {
          case "decimal":
            var tmpVal = val.toFixed(2);
            break;
          case "text":
            if (Object.keys(topo.conversion[att]).length == 1) {
              var tmpVal = val;
            }
            else {
              var tmpVal = topo.conversion[att][val];
            }
            break;
          case "integer":
            var tmpVal = val;
            break;
          case "date":
            var tmpTime = d3.time.format("%-m/%-d/%Y");
            var tmpVal = tmpTime(new Date(val));
            break;
        }
        if (Math.floor(val) == -9999) { tmpVal = "No Data"; };
        return tmpVal;
      }




      //******Add checkboxes to link crossfilters
      function addCFLinks(tmpLayers) {
        tmpLayers.forEach(function(layer1, i) {
          tmpLayers.forEach(function(layer2, j) {
            if (j > i) {
              d3.select("#linkLayers")
                .append("div")
                .attr("class", "hoverDiv")
                .attr("id", layer1 + "-" + layer2 + "-link")
                .property("title", "Check to spatially link the " + layer1.slice(0,-1) + " and " + layer2.slice(0,-1) + " layers");

              d3.select("#" + layer1 + "-" + layer2 + "-link")
                .append("label")
                .text("Link " + layer1 + " & " + layer2)
                .attr("class", "linkLabel")
                .attr("id", layer1 + "-" + layer2 + "-linkLabel")
                .html('<input id="' + layer1 + '-' + layer2 + '-check' + '" type="checkbox" class="linkCheck"></input><span>' + layer1.charAt(0).toUpperCase() + layer1.slice(1) + ' & ' + layer2.charAt(0).toUpperCase() + layer2.slice(1) + '</span>');

              d3.select("#" + layer1 + "-" + layer2 + "-check")
                .on("click", function() { checkLink("featureid", layer1, true); });   //Layer1 doesn't matter, just a placeholder
            }
          });
        });
      }
     



      //******Add properties to topos and push layer
      function addProps(tmpName, tmpK, tmpG, tmpID, tmpPieClass, tmpColor) {
        topos[tmpName][tmpK].class = tmpName;
        topos[tmpName][tmpK].g = tmpG;
        topos[tmpName][tmpK].uniqueID = tmpID;
        topos[tmpName][tmpK].pieClass = tmpPieClass;
        topos[tmpName][tmpK].covType = {};
        topos[tmpName][tmpK].color = tmpColor;
        if(tmpName == "struct") {
          topos[tmpName][tmpK].title = "Structure (K = " + tmpK.slice(1) + ")";
        }
        else if(tmpName == "dapc") {
          topos[tmpName][tmpK].title = "DAPC (K = " + tmpK.slice(1) + ")";
        }
        //topos[tmpName][tmpK].filter = {};
        //topos[tmpName][tmpK].binWidth = {};
        //topos[tmpName][tmpK].binCount = {};
        //brush[tmpName][tmpK] = {};
        //hist[tmpName][tmpK] = {};
        //layers.push(tmpName);
      }



      function addPolFilters(topo) {
        d3.select("#polFilterSelectDiv")
          .append("select")
          .attr("class", "filterAttrList pull-left")
          .attr("id", "classPolFilterSelect")
          .property("title", "Select class to use its values as options in the adjacent 'Area' selection box") 
          .on("change", function() { addPolFilterTypes(topo, this.value); })
          .on("mousedown", function() {  d3.select(this).select("option").style("display", "none"); });

        var optData = topo.keys.filter(function(key) { return key != "unique_id" && key != "featureid"; });
        optData.splice(0,0, "Select Class");

        var select = d3.select("#classPolFilterSelect");
        select.selectAll("option")
          .data(optData)
          .enter()
            .append("option")
              .attr("value", function (d) { if(d != "featureid") { return d;} })
              .property("disabled", function(d, i) { if(i == 0) {return "disabled";} })
              .text(function (d) { if(d == "Select Class") {return d;} else if(d != "featureid") {return topos.political.title[d];} });

        //******Add attribute selection box
        d3.select("#polFilterSelectDiv")
          .append("select")
          .attr("class", "filterAttrList pull-right")
          .attr("id", "typePolFilterSelect")
          .style("width", "227px");

        //******Add clear all button
        d3.select("#polFilterDiv")
          .append("button")
          .attr("class", "btn legendBtn")
          .attr("id", "polFilterClearBtn")
          .text("Clear All")
          .style({"margin-top":"10px", "display":"none"})
          .property("title", "Click to remove all applied filters")
          .on("click", function() { 
            var tmpArray = topos.political.condition.slice();
            tmpArray.forEach(function(cond) {
              var i = cond.indexOf("-") + 1;
              var j = cond.lastIndexOf("-");
              removeCondition(topo, cond, cond.slice(i,j), cond.slice(j+1)); 
            });
            d3.select(this).style("display", "none");
            d3.select("#typePolFilterSelect").property("selectedIndex", function() {return 0;});
          });

        //******Make array for holding filter conditions
        topo.condition = [];

        //******Initialise with first layer
        addPolFilterTypes(topo, "Select Class");
      }



      function addPolFilterTypes(topo, tmpKey) {
        var select = d3.select("#typePolFilterSelect")
          .property("title", "Select an area to filter features in the Crossings, Catchments, and Streams layers to those intersecting that area")
          .on("change", function() { addPolFilter(topo, tmpKey, this.value); resizePanels(); })
          .on("mousedown", function() {  d3.select(this).select("option").style("display", "none"); });

        //Get grouped data from crossfilter
        if(tmpKey == "Select Class") {
          var optData = [];
        }
        else {
          var optData = topo["catchments"].filter[tmpKey + "s"].all();
          optData = optData.map(function(d) { return d.key; } );
        }
        
        optData.splice(0,0, "Select Area");

        var options = select.selectAll("option")
          .data(optData);
       
        options.exit().remove();
        options.enter()
          .append("option");
        options
          .attr("value", function (d, i) { return optData[i].toString().replace(/ /g, "_"); })
          .property("disabled", function(d, i) { if(i==0) {return "disabled";} })
          .text(function (d, i) { return optData[i]; });

        //******Set selected index to 0
        d3.select("#typePolFilterSelect")
          .property("selectedIndex", function() {return 0;});
      }

     
      function addPolFilter(topo, tmpClass, tmpArea) {
        var tmpID = "polFilter--" + tmpClass + "--" + tmpArea;

        if (topo.condition.indexOf(tmpID) == -1 && tmpArea != "Select Area") {
          topo.condition.push(tmpID);

          if(topo.condition.length > 1) {
            d3.select("#polFilterClearBtn").style("display", "block"); 
          }
          else {
            d3.select("#polFilterClearBtn").style("display", "none"); 
          }
            
          d3.select("#polFilterConditions")
            .insert("div", ":first-child")
            .attr("class", "polFilterCond")
            .attr("id", tmpID)
            .append("p")
            //.text(tmpClass.charAt(0).toUpperCase() + tmpClass.slice(1) + " = " + tmpArea.replace(/_/g, " "))
            .text(topo.title[tmpClass] + " = " + tmpArea.replace(/_/g, " "))
            .style("display", "inline-block")
            .style("margin", "0px");

          d3.select("#" + tmpID)
            .append("span")
            .attr("class", "glyphicon glyphicon-remove pull-right minimize-button removeCond")
            .property("title", "Click to remove filter condition for " + topo.title[tmpClass] + " = " + tmpArea.replace(/_/g, " "))
            .on("click", function() { removeCondition(topo, tmpID, tmpClass, tmpArea); });
          
          //******Add filter to crossfilter
          applyPolCrossfilter(topo);
        }
      }


      function applyPolCrossfilter(topo) {
        //******Filter crossfilter values
        layers.forEach(function(layer) {
          topo.keys.forEach(function(key) {
            var tmpCond = [];
            topo.condition.forEach(function(cond) {
              var i = cond.indexOf("--") + 2;
              var j = cond.lastIndexOf("--");
              if (cond.slice(i,j) == key) {
                tmpCond.push(cond.slice(j + 2).replace(/_/g, " "));
              }
            });
            if (tmpCond.length > 0) {
              topo[layer].filter[key].filterFunction(function(d) { 
                return tmpCond.indexOf(d.toString()) > -1;
              });
            }
            else {
              topo[layer].filter[key].filterAll();
            }
          });
        });

        //*******Filter map by applied filters
        checkLink("featureid", topo, true);
      }



      function removeCondition(topo, tmpID, tmpClass, tmpArea) {
        topo.condition.splice(topo.condition.indexOf(tmpID), 1);

        if(topo.condition.length < 2) {
          d3.select("#polFilterClearBtn").style("display", "none"); 
        }

        d3.select("#" + tmpID).remove();
        applyPolCrossfilter(topo);
        if (d3.select("#typePolFilterSelect").node().value == tmpArea) {
          d3.select("#typePolFilterSelect").property("selectedIndex", function() {return 0;});
        }
      }




      function addFilterLayers(tmpLayers) {
        var select = d3.select("#filterLayers")
          .insert("select", ":first-child")
          .attr("class", "filterAttrList addChartForm")
          .attr("id", "layerFilterSelect")
          .property("title", "Select layer to use its attributes as options in the below 'Attribute' selection box") 
          .on("change", function() { addFilterSelect(topos[this.value]); })
          .on("mousedown", function() { d3.select(this).select("option").style("display", "none"); });

        var optLayers = tmpLayers.slice(0);
        optLayers.splice(0,0, "Select Layer");

        select.selectAll("option")
          .data(optLayers)
          .enter()
            .append("option")
            .attr("value", function (d, i) { return optLayers[i]; })
            .property("disabled", function(d, i) { if(i==0) {return "disabled";} })
            .text(function (d, i) { return optLayers[i].charAt(0).toUpperCase() + optLayers[i].slice(1); });

        //******Add attribute selection box
        var select = d3.select("#filterLayers")
          .insert("select", "#addChartButton")
          .attr("class", "filterAttrList addChartForm")
          .attr("id", "attributeFilterSelect")
          .on("change", function() {
            d3.select("#addChartButton")
              .property("title", "Click to add chart showing distribution of selected attribute values")
              .classed("disabled", false)
              .property("disabled", false);
            d3.select("#addChartButtonGlyph").classed("disabled", false);
          });

        //******Initialise with first layer
        addFilterSelect(topos[tmpLayers[0]]);

        //******Add values to totals portion of charts window
        tmpLayers.forEach(function(d) {
          var topo = topos[d];
          d3.select("#totals")
            .append("div")
            .attr("class", "hoverDiv")
            .property("title", "The number of " + topo.class + " currently selected out of the total number of " + topo.class)
            .html(topo.class.charAt(0).toUpperCase() + topo.class.slice(1) + ' selected: ' + '<b><span id="active-' + topo.class + '" style="color:#598cc0">' + topo[topo.cfGroup.all[0]].filter.all.value() + '</span></b> of <b><span id="total" style="color:black">' + topo[topo.cfGroup.all[0]].filter.all.value() + '</span></b>'); ;
        });
      }
        



      function addFilterSelect(topo) {
        var select = d3.select("#attributeFilterSelect")
          .attr("data-layer", topo.class)
          .property("title", "Select an attribute for display as an interactive graph containing the frequency of its values")
          .on("mousedown", function() {  d3.select(this).select("option").style("display", "none"); });

        if(d3.select("#layerFilterSelect").property("selectedIndex") == 0) {
          var optData = [];
        }
        else {
          var optData = topo.keys.filter(function(key) { return topo.display[key] == "yes"; });
        }

        optData.splice(0,0, "selectAttr");
        topo.title["selectAttr"] = "Select Attribute";
        topo.tooltip["selectAttr"] = "Select an attribute to display an interactive graph containing the frequency of its values";

        var options = select.selectAll("option")
          .data(optData);
       
        options.exit().remove();
        options.enter()
          .append("option");
        options
          .attr("value", function (d, i) { return optData[i]; })
          .property("disabled", function(d, i) { if(i==0) {return "disabled";} })
          .text(function (d, i) { return topo.title[optData[i]]; });

        //******Set selected index to 0
        d3.select("#attributeFilterSelect")
          .property("selectedIndex", function() {return 0;})
          .property("title", topo.tooltip["selectAttr"]);

        d3.select("#addChartButton")
          .property("title", "Select 'Layer' and 'Attribute' to enable addition of chart")
          .classed("disabled", true)
          .property("disabled", true);
        d3.select("#addChartButtonGlyph").classed("disabled", true);
      }






      function addLegend(topo) {
        d3.select("#legendDiv")
          .append("div")
          .attr("id", topo.class + "Legend" )
          .attr("class", "layerLegendDiv");

        d3.select("#" + topo.class + "Legend")
          .append("h5")
          .text(topo.class.charAt(0).toUpperCase() + topo.class.slice(1))
          .property("title", topo.class.charAt(0).toUpperCase() + topo.class.slice(1) + " feature layer")
          .attr("id", "legHead" + topo.class)
          .attr("class", "layerTitle");

        //***Add layer symbology after title
        d3.select("#" + topo.class + "Legend")
          .append("img")
          .property("src", "images/" + topo.class.slice(0,-1) + ".png")
          .attr("class", "legendSymbol")
          .property("title", function() { if(topo.class == "crossings") {return "Crossings are points";} else if(topo.class == "streams") {return "Streams are lines";} else {return "Catchments are polygons";} });

        //***Add check box for toggling SVG layers
        d3.select("#" + topo.class + "Legend")
          .append("span")
          .html('<input id="' +  topo.class + 'LayerChk" type="checkbox" class="pull-left" value="' + topo.class + '" title="Click to display/hide the ' + topo.class + ' layer" checked data-toggle="collapse" data-target="' + topo.class + 'LegendToggle"></input>');

        $('#' + topo.class + 'LayerChk').bootstrapToggle({on:'ON', off:'OFF', size:'mini', style:'on_off', width:'55px'});

        //***Toggle layer
        $('#' + topo.class + 'LayerChk').change(function() {
          if($(this).prop('checked')) {addTopo(topo); d3.select("#" + this.value + "Legend").select("img").style("display", "inline-block"); } else {removeTopo(topo); d3.select("#" + this.value + "Legend").select("img").style("display", "none");}
          $('#' + topo.class + 'LegendToggle').on('shown.bs.collapse', function() {  resizePanels(); });
          $('#' + topo.class + 'LegendToggle').collapse('toggle');
        });

        //***Give switch an id
        d3.select("#" + topo.class + "Legend").select(".toggle").attr("id", topo.class + "Switch");

        d3.select("#" + topo.class + "Legend")
          .append("div")
          .attr("id", topo.class + "LegendToggle")
          .attr("class", "collapse in")
          .append("hr")
          .attr("class", "legendHR");

        var select = d3.select("#" + topo.class + "LegendToggle")
          .append("p")
          .attr("class", "legendMapped")
          .text("Mapped:");

        var select = d3.select("#" + topo.class + "LegendToggle")
          .append("select")
          .attr("class", "legAttrList")
          .attr("id", topo.class + "Select")
          .on("change", function () { changeStyle(this.value, topo); });

        d3.select("#" + topo.class + "LegendToggle")
          .append("div")
          .attr("id", topo.class + "LegendUL")
          .attr("class", "legendUL");

        d3.select("#" + topo.class + "LegendToggle")
          .append("p")
          .attr("class", "legendTrans")
          .text("Transparency");

        d3.select("#" + topo.class + "LegendToggle")
          .append("input")
          .attr({type: "range", name: topo.class + "Opacity", min: 0, max: 100, value: 100})
          .attr("id", topo.class + "Slider")
          .property("title", topo.class.charAt(0).toUpperCase() + topo.class.slice(1) + " opacity: 100%")
          .on("input", function() { layerOpacity(this, topo); });

        //******Fill option data
        var optData = topo.keys.filter(function(key) { return topo.display[key] == "yes"; });

        select.selectAll("option")
          .data(optData)
          .enter().append("option")
          .attr("value", function (d, i) { return optData[i]; })
          .text(function (d, i) { return topo.title[optData[i]]; });
        
        select.insert("option", ":first-child")
          .attr("value", "...")
          .property("title", "Select an attribute to display its values on the map")
          .text("...");

        topo.tooltip["..."] = "Select an attribute to display its values on the map";
      }




      function layerOpacity(tmpEl, topo) {
        var tmpOpacity = tmpEl.value/100; 
        d3.select("#" + topo.class + "Slider").attr("value", tmpEl.value);
        var tmpData = topo[topo.cfGroup.all[0]].filter.featureid.top(Infinity);
        var tmpID = tmpData.map(function(d) {return d.featureid;});
        topo.g.selectAll("." + topo.class).style("opacity", function(d) {
          if(tmpID.indexOf(d.properties.featureid) > -1) {
            return tmpOpacity;
          }
          else {
            return 0;
          }
        });
        tmpEl.title = "Opacity: " + tmpEl.value + "%"; 
      } 


      function setArcRadius() {
        if(map.getZoom() > 16) {
          arc.outerRadius(map.getZoom() + 4);
        }
        else if(map.getZoom() > 13) {
          arc.outerRadius(map.getZoom() + 2);
        }
        else if(map.getZoom() > 10) {
          arc.outerRadius(map.getZoom());
        }
        else {
          arc.outerRadius(map.getZoom() - 2);
        }
      }



      //*****Reposition the SVG to cover the features.
      function reset() {
        layers.forEach(function(d) {
          removeTopo(d, false);
        });

        path.pointRadius(map.getZoom() - 2);
        setArcRadius();

        
        //******Set bounds (using Deerfield HUC 8 bounds)
        var bottomLeft = projectPoint(bounds[0]);
        var topRight = projectPoint(bounds[1]);
          
        wildSVG.attr('width', topRight[0] - bottomLeft[0])
          .attr('height', bottomLeft[1] - topRight[1])
          .style('margin-left', bottomLeft[0] + 'px')
          .style('margin-top', topRight[1] + 'px');


        //******Select all layer g elements
        var tmpG = wildSVG.selectAll("g");

        //******Loop through each g element and transform the path
        tmpG[0].forEach(function(g) {
          var curG = d3.select(g);
          curG.attr('transform', 'translate(' + -bottomLeft[0] + ',' + -topRight[1] + ')');
        }); 
 
        if(layers.length > 0) {
          addTopo(layers[layers.length -1]);
        }
      }





      //*****Reposition the SVG to cover the features.
      function resetLegend() {
        arc.outerRadius(20);
        
        //******Set bounds (using Deerfield HUC 8 bounds)
        var bottomLeft = projectPointLegend(boundsLegend[0]);
        var topRight = projectPointLegend(boundsLegend[1]);
          
        hatchSVG.attr('width', topRight[0] - bottomLeft[0])
          .attr('height', bottomLeft[1] - topRight[1])
          .style('margin-left', bottomLeft[0] + 'px')
          .style('margin-top', topRight[1] + 'px');


        //******Select all layer g elements
        var tmpG = hatchSVG.selectAll("g");

        //******Loop through each g element and transform the path
        tmpG[0].forEach(function(g) {
          var curG = d3.select(g);
          curG.attr('transform', 'translate(' + -bottomLeft[0] + ',' + -topRight[1] + ')');
        }); 
       }




      //******Use Leaflet to implement a D3 geometric transformation.
      function projectPoint(x) {
        var point = map.latLngToLayerPoint(new L.LatLng(x[1], x[0]));
        return [point.x, point.y];
      }


      //******Use Leaflet to implement a D3 geometric transformation.
      function projectPointLegend(x) {
        var point = legendMap.latLngToLayerPoint(new L.LatLng(x[1], x[0]));
        return [point.x, point.y];
      }







      //******Change number strings to values
      function strToNum(tmpData) {
        var tmpKeys = d3.keys(tmpData[0]);

        var tmpCov = tmpData.map(function(d) {
          var tmpJSON = {};
          var tmpVals = d3.values(d);
          tmpVals.forEach(function(val,i){ 
            if (val == "NA") {
              tmpJSON[tmpKeys[i]] = -9999;
            }
            else if (isNaN(val) == false) {
              tmpJSON[tmpKeys[i]] = +d[tmpKeys[i]];
            }
            else {
              if (val.indexOf("/") > -1) {
                tmpJSON[tmpKeys[i]] = Date.parse(val);
              }
              else { 
                tmpJSON[tmpKeys[i]] = d[tmpKeys[i]];
              }
            }
          });
          return tmpJSON;
        });
        return tmpCov
      }



      //******Transform TSV strings to values if appropriate and add to topojson
      function readTSV(tmpData, topo) {
        //******Get keys and values from TSV data and fill out covariate data type
        var tmpKeys = d3.keys(tmpData[0]);
        var tmpVals = d3.values(tmpData[0]);

        tmpVals.forEach(function(val,i){
          if (isNaN(val) == false || val == "NA") {
            topo.covType[tmpKeys[i]] = "number";
          }
          else {
            topo.covType[tmpKeys[i]] = "string";
          }
        });

        //******Change TSV attribute strings to values if appropriate
        var tmpCov = strToNum(tmpData);

        //*******Map TSV to ID_key attribute (in this case either unique_id (crossings, streams) or featureid (catchments)
        var tmpMap = d3.map(tmpCov, function(d) {return d[topo.uniqueID];});

        //*******Add TSV data to topojson
        topo.features.forEach(function(d) { 
          try {
            tmpKeys.forEach(function(key) {
                d.properties[key] = tmpMap.get(d.id)[key];
            });
          }
          catch(err) { 
            console.log("No TSV data for id " + d.id);
          }
        });

        return tmpCov;
      }





      //*******Make crossfilter dimensions and grouped dimensions
      function cfDimension(topo, covariates) {
        //******Assign covariates to a crossfilter variable
        var tmpCovariates = {};

        topo.cfGroup.all.forEach(function(group) {
          tmpCovariates[group] = [];
          covariates.forEach(function(row) {
            var tmpRow = {};
            topo[group].keys.forEach(function(key) {
              if(topo.cfGroup[key] == group || topo.cfGroup[key] == "both") {
                tmpRow[key] = row[key];
              }
            });
            tmpCovariates[group].push(tmpRow);
          });
        });

      topo.cfGroup.all.forEach(function(group) {     
        var tmpCF = crossfilter(tmpCovariates[group]);
        topo[group].filter.all = tmpCF.groupAll();
        var lowKey = 0;

        //******Dimension and group each covariate
        topo[group].keys.forEach(function(key, i) {
          topo[group].filter[key] = tmpCF.dimension(function(d) { return d[key]; } );
          if (topo.covType[key] == "number") {
            var tmpTop = topo[group].filter[key].top(1);
            var tmpBot = topo[group].filter[key].bottom(Infinity);
            for (var i = 0; i < tmpBot.length; i++) {
              if (tmpBot[i][key] > -9999) {
                lowKey = i;
                break;
              }
            }
            topo.minVal[key] = tmpBot[lowKey][key];
            topo.maxVal[key] = tmpTop[0][key];

            if (topo.scale[key] == "categorical") {
              topo.binCount[key] = topo[group].filter[key].group().size();
              topo.catFilter[key] = [];
            }
            else {
              topo.binCount[key] = 40;
            }

            var divVal = (tmpTop[0][key] - tmpBot[lowKey][key]) / topo.binCount[key];
            topo.binWidth[key] = divVal;
            topo[group].filter[key + "s"] = topo[group].filter[key].group(function(d) { if(topo.scale[key] == "categorical") {return d;} else {return Math.floor(d / divVal) * divVal;}});

            topo.minClip[key] = topo[group].filter[key + "s"].all()[0].key;
            if (topo.minClip[key] <= -9998) {
              topo.minClip[key] = topo[group].filter[key + "s"].all()[1].key;
            }
            topo.maxClip[key] = topo[group].filter[key + "s"].all()[topo[group].filter[key + "s"].size() - 1].key + topo.binWidth[key];
 
            topo.catFilter[key] = topo[group].filter[key + "s"].all().map(function(d) {return d.key; });
          }
          else {
            topo[group].filter[key + "s"] = topo[group].filter[key].group();
          }
        });
      });
      }






      //*******Show crossings attribute in tooltip
      function showIt(tmpID, tmpData, i, topo) {
        tooltip.html(tmpID);
        tooltip.style("visibility", "visible");
        tooltip.property("title", tmpID);
        tooltip.append("div")
          .attr("id","piechart")
          .style({"width":"600px", "height":"400px"});
       
        var data = [["k","prob"]];
        tmpData.data.forEach(function(d,i) {
          if(tmpData.data.length < 10) {
            data.push(["K" + (i + 1), +d]); 
          }
          else if(i < tmpData.data.length -1) {
            data.push(["K" + (i + 1), +d]);
          }
          else {
            data.push(["Other", +d]);
          }
        });
        var chartData = google.visualization.arrayToDataTable(data);
        var options = {
          backgroundColor: "transparent",
          colors: topo.color,
          legend: {position: 'right', alignment: "center", textStyle: {color: 'white', fontSize: 16}},
          pieSliceText: "value",
          chartArea: {height: 350, top: 0, left: 0},
          enableInteractivity: false,
          sliceVisibilityThreshold: 0.000001
        };

        var chart = new google.visualization.PieChart(document.getElementById('piechart'));
        chart.draw(chartData, options);
        
        //***Highlight selected slice NOTE: doesn't work because google charts doesn't append slices in order
        //var tmpG = d3.select("#piechart").select("svg").selectAll(function() { return this.childNodes; }).filter("g")[0][i+1];
        //d3.select(tmpG).select("path").attr("stroke", "#ffff00");
        //d3.select(tmpG).select("path").attr("stroke-width",3);
      }




      //*******Transform data
      function transformData(scale, data, tmpMax) {
        switch(scale) {
          case "linear":
            var normVals = data.map(function(d) { return d; });
            break;
          case "log":
            var normVals = data.map(function(d) { return Math.log(d + 0.1); });
            break;
          case "log_rec":
            var normVals = data.map(function(d) { return Math.exp(d + 0.01); });
            //var normVals = data.map(function(d) { return -(Math.log((tmpMax + 0.01) - d)); });
            break
          case "categorical":
            var normVals = data.map(function(d) { return d; });
            break;
        }

        return normVals;
      }





      //*******Back Transform data
      function backTransformData(scale, data, tmpMax) {
        switch(scale) {
          case "linear":
            var normVals = data.map(function(d) { return d; });
            break;
          case "log":
            var normVals = data.map(function(d) { return Math.exp(d) - 0.1; });
            break;
          case "log_rec":
            var normVals = data.map(function(d) { return Math.log(d) - 0.01; });
            //var normVals = data.map(function(d) { return tmpMax + 0.01 - Math.exp(-d); });
            break
          case "categorical":
            var normVals = data.map(function(d) { return d; });
            break;
        }

        return normVals;
      }





      //*******Change feature styles
      function changeStyle(tmpAtt, topo) {
        //*******Change tooltip text for select
        //d3.select("#" + topo.class + "Select").property("title", topo.tooltip[tmpAtt]);

        //*******Select features
        var curG = d3.select(topo.g[0][0]);
        var tmpFeat = curG.selectAll("." + topo.class);

        //******Remove colors from layer and legend when ... is selected
        if (tmpAtt == "...") {
          tmpFeat.style({"stroke":"gray","fill":"gray","fill-opacity":"0.01"});
          tmpFeat.attr("id", "...");
        
          d3.select("#" + topo.class + "-list-inline").selectAll("li")
            .style({"border-top-color":"gray", "color":"white"})
            .property("title", "");
        }
        else {
          //*******Get data for passed in attribute
          var tmpVals = d3.values(topo.features).map(function(d) { return d.properties[tmpAtt]; });

          //*Filter out "NA" data
          tmpVals = tmpVals.filter(function(val) {if(val > -9999){return true} else {return false};});

          //*******Normalise scale
          var maxVal = d3.max(tmpVals);
          var normVals = transformData(topo.scale[tmpAtt], tmpVals, maxVal);
  
          var tmpSet = d3.set(normVals);
          var tmpMin = d3.min([6, tmpSet.size()])

          //*******Make a color scale
          var colorArray = colorbrewer[topo.color][tmpMin].slice(0);
          if (topo.direction[tmpAtt] == "reverse") {
            colorArray.reverse();
          }
        
          if(topo.scale[tmpAtt] == "categorical") {
            var catArray = d3.keys(tmpSet._);
            var newColor = d3.scale.ordinal()
              .domain(catArray)
              .range(colorArray);
          }
          else {
            var newColor = d3.scale.quantize()
              .domain([d3.min(normVals), d3.max(normVals)])
              .range(colorArray);
          }

          //*******Style and label crossings by attribute value
          if (topo.class == "streams") {
            tmpFeat.style("stroke", function(d) {
              if (d.properties[tmpAtt] > -9999) { 
                var tVal = transformData(topo.scale[tmpAtt], [d.properties[tmpAtt]], maxVal);
                return newColor(tVal[0])
              }
              else {return "gray"}; 
            });
          }
          else {
            tmpFeat.style({"stroke":"","fill-opacity":""});
            tmpFeat.style("fill", function(d) {
              if (d.properties[tmpAtt] > -9999) { 
                var tVal = transformData(topo.scale[tmpAtt], [d.properties[tmpAtt]], maxVal);
                return newColor(tVal[0])
              }
              else {return "gray"}; 
            });
          }

          tmpFeat.attr("id", function(d) { 
            if(d.properties[tmpAtt] > -9999) {
              switch(topo.data_type[tmpAtt]) {
                case "decimal":
                  return (topo.title[tmpAtt] + ": " + d.properties[tmpAtt].toFixed(2) + " " + topo.unit[tmpAtt]);
                  break;
                case "integer":
                  return (topo.title[tmpAtt] + ": " + d.properties[tmpAtt] + " " + topo.unit[tmpAtt]);
                  break;
                case "date":
                  var formatDate = d3.time.format("%-m/%-d/%Y");
                  return (topo.title[tmpAtt] + ": " + formatDate(new Date(d.properties[tmpAtt])));
                  break;
                case "text":
                  return (topo.title[tmpAtt] + ": " + topo.conversion[tmpAtt][d.properties[tmpAtt]]);
                  break;
              }
            }
            else {
              return (topo.title[tmpAtt] + ": No Data");
            }
          })

          //*******Make a legend
          var list = d3.select("#" + topo.class + "-list-inline");
          list.remove();
 
          var legend = d3.select("#" + topo.class + "LegendUL")
           .append("ul")
           .attr("id", topo.class + "-list-inline")
           .attr("class", "legend-colors")
           .property("title", topo.tooltip[tmpAtt]);

          var keys = legend.selectAll("li.key")
            .data(newColor.range());
 
          keys.enter().append("li")
            .attr("class", "key")
            .style("border-top-color", String)
            .text(function(d, i) {
              if(topo.scale[tmpAtt] != "categorical") {
                var r = newColor.invertExtent(d);
                tmpR = backTransformData(topo.scale[tmpAtt], r, topo.max[tmpAtt]);
              }
              switch(topo.data_type[tmpAtt]) {
                case "decimal":
                  return tmpR[0].toFixed(2);
                  break;
                case "integer":
                  return tmpR[0].toFixed(1);
                  break;
                case "date":
                  var tmpDate = new Date(tmpR[0]);
                  var shortDate = d3.time.format("%-m/%Y");
                  return shortDate(tmpDate);
                  break;
                case "text":
                  return topo.conversion[tmpAtt][catArray[i]];
                  break;
              }  
            })
            .property("title", function() {return d3.select(this).text();});
        }
      }





      //*******Add crossfilter histogram
      function addFilter(tmpKey, topo) {
        //*******Change tooltip text for select
        d3.select("#attributeFilterSelect").property("title", topo.tooltip[tmpKey]);

        if (graphs.indexOf(topo.class + "-" + tmpKey) > -1 || tmpKey == "selectAttr") {
          return;
        }
        else {
          graphs.push(topo.class + "-" + tmpKey);
        }

        //******Define graph attributes
        var margin = {top: 10, right: 10, bottom: 20.5, left: 10.5},
          width = 380 - margin.left - margin.right,
          height = 100 - margin.top - margin.bottom;

        if (topo.scale[tmpKey] == "categorical") {
          var x = d3.scale.ordinal().rangeRoundBands([0, width], 0.1, 0.1);
        }
        else {
          var x = d3.scale.linear().rangeRound([0, width]);
        }

        var y = d3.scale.linear().range([height, 0]);

        var xAxis = d3.svg.axis()
          .scale(x)
          .orient("bottom");

        //**Format ticks for special data types
        switch(topo.data_type[tmpKey]) {
          case "date":
            xAxis.tickFormat(function(d) { var tmpDate = d3.time.format("%-m/%Y"); return tmpDate(new Date(d)); });
            xAxis.ticks(5);
            break;
          case "text":
            xAxis.tickFormat(function(d) { return topo.conversion[tmpKey][d]; });
            xAxis.ticks(Object.keys(topo.conversion[tmpKey]).length - 1);
            break;
          default:
            var twoDec = d3.format(".2f");
            switch(topo.scale[tmpKey]) {
              case "log":
                xAxis.tickFormat(function(d) { return twoDec(Math.exp(d)); });
                xAxis.ticks(5);
                break;
              case "log_rec":
                xAxis.tickFormat(function(d) { return twoDec(Math.log(d) - 0.01); });
                //xAxis.tickFormat(function(d) { return twoDec(topo.max[tmpKey] - Math.exp(-d)); });
                xAxis.ticks(5);
                break;
              default:
                xAxis.tickFormat(function(d) { return twoDec(d); });
                xAxis.ticks(5);
            }
        }

        //******Add brush
          brush[topo.class][tmpKey] = d3.svg.brush()
            .x(x)
            .on("brushstart", function() { brushStart(tmpKey, topo); })
            .on("brush", function() { brushMove(tmpKey, topo); })
            .on("brushend", function() { brushEnd(tmpKey, topo); });

        //******Add chart div, title div, and reset option
        d3.select("#charts")
          .insert("div", ":first-child")
            .attr("class", "chart")
            .attr("id", topo.class + "-" + tmpKey)
            .property("title", function() {if(topo.scale[tmpKey] == "categorical") { return "Click bar to select/unselect category"; } else { return "Click and drag inside chart to select data"; } })
          .append("div")
            .attr("class", "title")
            .attr("id", "title-" + topo.class + "-" + tmpKey)
            .style("margin-left", "2px")
            .property("title", topo.tooltip[tmpKey])
            .text(topo.class.charAt(0).toUpperCase() + topo.class.slice(1) + ": " + topo.title[tmpKey])
          .append("a")
            .attr("class", "reset")
            .attr("id", "reset-" + topo.class + "-" + tmpKey)
            .text("reset")
            .style("display", "none")
            .property("title", "Click to clear selection box from chart")
            .on("click", function() { brushReset(tmpKey, topo); });


        //******Add remove button
        d3.select("#title-" + topo.class + "-" + tmpKey)
          .append("span")
            .attr("class", "glyphicon glyphicon-remove pull-right minimize-button")
            .attr("id", topo.class + "-" + tmpKey)
            .property("title", "Click to remove chart for " + topo.class.charAt(0).toUpperCase() + topo.class.slice(1) + ": " + topo.title[tmpKey])
            .style({"color":"red","margin-left":"14px"})
            .on("click", function() { removeFilter(this.id, topo); });

        //******Add stats div and extent
        if (topo.scale[tmpKey] != "categorical") {
          d3.select("#" + topo.class + "-" + tmpKey)
            .append("div")
              .attr("class", "stats")
              .attr("id", "stats-" + topo.class + "-" + tmpKey);

          var statsDiv = d3.select("#stats-" + topo.class + "-" + tmpKey);

          statsDiv.append("input")
            .attr({type: function() {if(topo.data_type[tmpKey] == "date") {return "text";} else { return "number"}} })
            .attr("class", "extent-input")
            .attr("id", "extent-input-lower-" + topo.class + "-" + tmpKey)
            .property("title", "Lower value for selected range of " + topo.title[tmpKey] + " distribution");

          statsDiv.append("p")
            .attr("class", "extent-input-p")
            .text("-");

          statsDiv.append("input")
            .attr({type: function() {if(topo.data_type[tmpKey] == "date") {return "text";} else { return "number"}} })
            .attr("class", "extent-input")
            .attr("id", "extent-input-upper-" + topo.class + "-" + tmpKey)
            .property("title", "Upper value for selected range of " + topo.title[tmpKey] + " distribution");

          statsDiv.append("p")
            .attr("class", "extent-input-p")
            .text(topo.unit[tmpKey]);


          //******Add mean to stats div
          d3.select("#stats-" + topo.class + "-" + tmpKey)
            .append("span")
              .attr("class", "mean pull-right")
              .attr("id", "mean-" + topo.class + "-" + tmpKey)
              .property("title", "Average of selected values");
        }

        //******Add svg
        var svg = d3.select("#" + topo.class + "-" + tmpKey)
          .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .attr("id", "svg-" + topo.class + "-" + tmpKey)
          .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
            .attr("id", "g-" + topo.class + "-" + tmpKey);

        //******Add clip path rectangle
        if (topo.scale[tmpKey] != "categorical") {
          svg.append("clipPath")
            .attr("id", "clip-" + topo.class + "-" + tmpKey)
            .append("rect")
              .attr("width", width)
              .attr("height", height);
        }

        //******Get data and make graph
        if(topo.cfGroup[tmpKey] == "both") {
          var tmpGroup = topo.cfGroup.all[0];
        }
        else {
          var tmpGroup = topo.cfGroup[tmpKey];
        }

        var tmpData = topo[tmpGroup].filter[tmpKey + "s"].all();

        var lowKey = 0;
        if (tmpData[0].key < -9998) {
          lowKey = 1;
        }

        if (topo.scale[tmpKey] == "categorical") {
          tmpData = tmpData.filter(function(d) { return d.key > -9999; });
          x.domain(tmpData.map(function(d) {if(d.key > -9999) { return d.key;} }));
        }
        else {
          x.domain([tmpData[lowKey].key, tmpData[tmpData.length - 1].key + topo.binWidth[tmpKey]]);
        }
        y.domain([0, d3.max(tmpData, function(d) { if ( d.key > -9999) { return d.value; } })]);

        //******Add Axis
        var tmpX = svg.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + height + ")")
          .call(xAxis);

        hist[topo.class][tmpKey] = {"x": x, "y": y, "height": height, "width": width};
      
        //******Add background bars
        if (topo.scale[tmpKey] != "categorical") {
          svg.selectAll(".background.bar")
              .data(tmpData)
            .enter().append("rect")
              .attr("class", "background bar")
              .attr("x", function(d) { return x(d.key); })
              .attr("width", function() { if(topo.scale[tmpKey] == "categorical") { return x.rangeBand(); } else { return width / topo.binCount[tmpKey]; } })  
              .attr("y", function(d) { return y(d.value); })
              .attr("height", function(d) { return height - y(d.value); })
              .append("svg:title")
                .text(function(d) { return d.key + ": " + d.value; });
        }

        //******Add foreground bars
        svg.selectAll(".foreground.bar")
            .data(tmpData)
          .enter().append("rect")
            .attr("class", "foreground bar")
            .classed("categorical", function() { return topo.scale[tmpKey] == "categorical"; })
            .attr("x", function(d) { return x(d.key); })
            .attr("width", function() { if(topo.scale[tmpKey] == "categorical") { return x.rangeBand(); } else { return width / topo.binCount[tmpKey]; } })  
            .attr("y", function(d) { return y(d.value); })
            .attr("height", function(d) { return height - y(d.value); })
            .on("mouseover", function() { if(topo.scale[tmpKey] == "categorical") { d3.select(this).style("cursor", "crosshair"); } })
            .on("click", function() { catBarStyle(topo, tmpKey, this); })
            .append("svg:title")
              .text(function(d) { if(topo.scale[tmpKey] == "categorical") { return topo.conversion[tmpKey][d.key] + ": " + d.value; } else { return d.key + ": " + d.value; } });

        //******Add Brush
        if (topo.scale[tmpKey] != "categorical") {
          svg.selectAll(".foreground.bar")
            .attr("clip-path", "url(#clip-" + topo.class + "-" + tmpKey + ")");
      
          var gBrush = svg.append("g")
            .attr("class", "brush")
            .attr("id", "brush-" + topo.class + "-" + tmpKey)
            .call(brush[topo.class][tmpKey]);

          gBrush.selectAll("rect").attr("height", height);
          gBrush.selectAll(".resize").append("path").attr("d", resizePath);

          //******* Set upper and lower brush properties
          var inpMin = backTransformData(topo.scale[tmpKey], [topo.minClip[tmpKey]], topo.max[tmpKey]);
          var inpMax = backTransformData(topo.scale[tmpKey], [topo.maxClip[tmpKey] + topo.binWidth[tmpKey]], topo.max[tmpKey]);

          var tmpLower = d3.select("#extent-input-lower-" + topo.class + "-" + tmpKey)
            .property("min", Math.floor(inpMin*100)/100)
            .property("max", Math.ceil(inpMax*100)/100)
            .property("step", Math.round((inpMax - inpMin))/100);

          var tmpUpper = d3.select("#extent-input-upper-" + topo.class + "-" + tmpKey)
            .property("min", Math.floor(inpMin*100)/100)
            .property("max", Math.ceil(inpMax*100)/100)
            .property("step", Math.round((inpMax - inpMin))/100);

          d3.select("#extent-input-lower-" + topo.class + "-" + tmpKey).on("change", function () {extentChange(tmpKey, topo, tmpLower, tmpUpper); });
          d3.select("#extent-input-upper-" + topo.class + "-" + tmpKey).on("change", function () {extentChange(tmpKey, topo, tmpLower, tmpUpper); });      

          brushReset(tmpKey, topo);
        }

        function resizePath(d) {
          var e = +(d == "e"),
            x = e ? 1 : -1,
            y = height / 3;
          return "M" + (0.5 * x) + "," + y + "A6,6 0 0 " + e + " " + (6.5 * x) + "," + (y + 6) + "V" + (2 * y - 6) + "A6,6 0 0 " + e + " " + (0.5 * x) + "," + (2 * y) + "Z" + "M" + (2.5 * x) + "," + (y + 8) + "V" + (2 * y - 8) + "M" + (4.5 * x) + "," + (y + 8) + "V" + (2 * y - 8);
        }

      }








      //******Remove graph from window
      function removeFilter(class_key, topo) {
        var dash = class_key.indexOf("-");
        var tmpClass = class_key.slice(0, dash);
        var key = class_key.slice(dash + 1, class_key.length);

        graphs.splice(graphs.indexOf(class_key), 1);
        brushReset(key, topo);
        var select = d3.select("#" + class_key);
        select.remove();

        //******If select dropdown is this attribute change back to ...
        if (d3.select("#attributeFilterSelect").node().value == key) {
          d3.select("#attributeFilterSelect").property("selectedIndex", function() {return 0;});
        }
      }





      function extentChange(tmpKey, topo, tmpLower, tmpUpper) {
        if (topo.data_type[tmpKey] == "date") {         
          var valLow = Date.parse(tmpLower.property("value"));
          var valHigh = Date.parse(tmpUpper.property("value"));
        }
        else {
          var valLow = parseFloat(tmpLower.property("value"));
          var valHigh = parseFloat(tmpUpper.property("value"));
        }

        if (valLow > valHigh) {
          var tmpHold = tmpUpper.property("value");
          tmpUpper.property("value", tmpLower.property("value"));
          tmpLower.property("value", tmpHold);
          tmpHold = valHigh;
          valHigh = valLow;
          valLow = tmpHold;
        }

        var inpMin = transformData(topo.scale[tmpKey], [valLow], topo.max[tmpKey])[0];
        var inpMax = transformData(topo.scale[tmpKey], [valHigh], topo.max[tmpKey])[0];

        d3.select("#brush-" + topo.class + "-" + tmpKey).call(brush[topo.class][tmpKey].extent([inpMin, inpMax]));
        brushEnd(tmpKey, topo);
      }


      function brushStart(tmpKey, topo) {
        if(topo.cfGroup[tmpKey] == "both") {
          var tmpGroup = topo.cfGroup.all[0];
        }
        else {
          var tmpGroup = topo.cfGroup[tmpKey];
        }

       topo[tmpGroup].filter[tmpKey].filterRange([brush[topo.class][tmpKey].extent()[0], brush[topo.class][tmpKey].extent()[1]]);
       checkLink(tmpKey, topo, false);
      }


      function brushMove(tmpKey, topo) {
        if(topo.cfGroup[tmpKey] == "both") {
          var tmpGroup = topo.cfGroup.all[0];
        }
        else {
          var tmpGroup = topo.cfGroup[tmpKey];
        }

        topo[tmpGroup].filter[tmpKey].filterRange([brush[topo.class][tmpKey].extent()[0], brush[topo.class][tmpKey].extent()[1]]);
        checkLink(tmpKey, topo, false);
      }


      function brushEnd(tmpKey, topo) {
        if(topo.cfGroup[tmpKey] == "both") {
          var tmpGroup = topo.cfGroup.all[0];
        }
        else {
          var tmpGroup = topo.cfGroup[tmpKey];
        }

        if(topo.scale[tmpKey] != "categorical") {
          topo[tmpGroup].filter[tmpKey].filterRange([brush[topo.class][tmpKey].extent()[0], brush[topo.class][tmpKey].extent()[1]]);       
          d3.select("#reset-" + topo.class + "-" + tmpKey).style("display", "inline-block");
        }
        else {
          var tmpVals = [];
          d3.select("#g-" + topo.class + "-" + tmpKey).selectAll(".foreground.bar").filter(function(d) { if(d3.select(this).style("fill") == "rgb(70, 130, 180)") { tmpVals.push(d.key); } });
          topo[tmpGroup].filter[tmpKey].filterFunction(function(d) { return tmpVals.indexOf(d) != -1; }); //if(tmpVals.indexOf(d) > -1) { return true;} else { return false;} }); 
        }
        checkLink(tmpKey, topo, false);
        
      }

      function brushReset(tmpKey, topo) {
        if(topo.cfGroup[tmpKey] == "both") {
          var tmpGroup = topo.cfGroup.all[0];
        }
        else {
          var tmpGroup = topo.cfGroup[tmpKey];
        }

        if(topo.scale[tmpKey] != "categorical") {
          d3.select("#brush-" + topo.class + "-" + tmpKey).call(brush[topo.class][tmpKey].clear());
          topo[tmpGroup].filter[tmpKey].filterAll();
        }
        else {
          d3.select("#g-" + topo.class + "-" + tmpKey).selectAll(".foreground.bar").style({"fill":"steelblue","stroke":"steelblue"});
          topo[tmpGroup].filter[tmpKey].filterAll();
          topo.catFilter[tmpKey] = topo[tmpGroup].filter[tmpKey + "s"].all().map(function(d) {return d.key; });
        }
        checkLink(tmpKey, topo, false);
        d3.select("#reset-" + topo.class + "-" + tmpKey).style("display", "none");
      }


      function filterMap(tmpKey, topo, isLink) {
        if(topo.cfGroup[tmpKey] == "both") {
          var tmpGroup = topo.cfGroup.all[0];
        }
        else {
          var tmpGroup = topo.cfGroup[tmpKey];
        }
        var tmpSubset = topo[tmpGroup].filter[topo.uniqueID].top(Infinity);
        var tmpID = tmpSubset.map(function(d) {return d[topo.uniqueID];});
        var tmpData = d3.selectAll("." + topo.class).data();
        var tmpSel = d3.selectAll("." + topo.class);
        var tmpSlider = d3.select("#" + topo.class + "Slider").attr("value")/100;
        tmpSel.style("opacity", function(d, i) { 
          if (tmpID.indexOf(tmpData[i].properties[topo.uniqueID]) > -1) {
            return tmpSlider;
          }
          else {
            return 0;
          }
        });

        //******Update features selected
        d3.select("#active-" + topo.class).html(topo[tmpGroup].filter.all.value());

        //******Update filter range (if isLink == false)
        if (isLink == false) {
          if (brush[topo.class][tmpKey].empty() && topo[tmpGroup].filter.all.value() > 0) {
            setInputs(topo, tmpKey, topo.minVal[tmpKey], topo.maxVal[tmpKey], topo.minClip[tmpKey], topo.maxClip[tmpKey]);
          }
          else {
            var extMin = brush[topo.class][tmpKey].extent()[0]
            var extMax = brush[topo.class][tmpKey].extent()[1]
            setInputs(topo, tmpKey, extMin, extMax, extMin, extMax);
          }
        }
      }



      //******Set lower and upper input values and adjust clip path
      function setInputs(topo, tmpKey, tmpMin, tmpMax, clipMin, clipMax) {
        var inpMin = backTransformData(topo.scale[tmpKey], [clipMin], topo.max[tmpKey])[0];
        var inpMax = Math.ceil(backTransformData(topo.scale[tmpKey], [clipMax], topo.max[tmpKey])[0]*100)/100;

        if (topo.data_type[tmpKey] == "date") {
          var tmpFormat = d3.time.format("%m/%d/%Y");
          d3.select("#extent-input-lower-" + topo.class + "-" + tmpKey).property("value", tmpFormat(new Date(inpMin)));
          d3.select("#extent-input-upper-" + topo.class + "-" + tmpKey).property("value", tmpFormat(new Date(inpMax)));
        }
        else {
          d3.select("#extent-input-lower-" + topo.class + "-" + tmpKey).property("value", Math.round(inpMin*100)/100);
          d3.select("#extent-input-upper-" + topo.class + "-" + tmpKey).property("value", Math.round(inpMax*100)/100);
        }

        d3.select("#clip-" + topo.class + "-" + tmpKey + " rect")
          .attr("x", hist[topo.class][tmpKey].x(clipMin))
          .attr("width", hist[topo.class][tmpKey].x(clipMax) - hist[topo.class][tmpKey].x(clipMin));
      }





      //******Set featureid according to which layers are linked and political filters
      function checkLink(tmpKey, topo, isLink) {
        //console.log(arguments.callee.caller.name);
        //******Return array of layers that are linked 
        var linkLayers = getLinkIDs();

        //******Filter the map based on common featureids
        layers.forEach(function(layer) {
          if (isLink == false && layer == topo.class) {
            filterMap(tmpKey, topos[layer], false);
          }
          else if(isLink == false && linkLayers.indexOf(layer) > -1) {
            filterMap("featureid", topos[layer], true);
          }
          else if(isLink == true) {
            filterMap("featureid", topos[layer], true);
          }
        });

        updateStats(tmpKey);

        updateHistogram(tmpKey);
      }




      //******Determine linked layers
      function getLinkIDs() {
        //console.log(arguments.callee.caller.name);
        //******Determine which layers are linked
        var linkLayers = [];

        layers.forEach(function(layer1, i) {
          topos[layer1].cfGroup.all.forEach(function(group1) {
            layers.forEach(function(layer2, j) {
              if (j > i) {
                topos[layer2].cfGroup.all.forEach(function(group2) {
                  topos[layer1][group1].filter.featureid.filterAll();
                  topos[layer2][group2].filter.featureid.filterAll();
                  if(layer1 != "catchments") topos[layer1][group1].filter.unique_id.filterAll();
                  if(layer2 != "catchments") topos[layer2][group2].filter.unique_id.filterAll();

                  if (d3.select("#" + layer1 + "-" + layer2 + "-check").property("checked") == true) {
                    if (linkLayers.indexOf(layer1) == -1) {
                      linkLayers.push(layer1);
                    }
                    if (linkLayers.indexOf(layer2) == -1) {
                      linkLayers.push(layer2);
                    }
                  }
                });
              }
            });
          });
        });


        //******Apply political filters
        if(topos.political.condition.length > 0) {
          layers.forEach(function(layer) {
            var polSubset = topos.political[layer].filter[topos[layer].uniqueID].top(Infinity);
            var polIDs = polSubset.map(function(d) {return d[topos[layer].uniqueID];});

            topos[layer].cfGroup.all.forEach(function(group) {
              topos[layer][group].filter[topos[layer].uniqueID].filterFunction(function(d,i) {
                return polIDs.indexOf(d) != -1;
              });
            });
          });
        }


        //******Filter layers to common featureids between groups within a layer
        IDs = [];
        layers.forEach(function(layer) {
          if(topos[layer].cfGroup.all.length > 1) {
            //***Get common feature ids
            topos[layer].cfGroup.all.forEach(function(group1, i) {
              var tmpSubset = topos[layer][group1].filter[topos[layer].uniqueID].top(Infinity);
              var tmpID1 = tmpSubset.map(function(d) {return d[topos[layer].uniqueID];});

              topos[layer].cfGroup.all.forEach(function(group2, j) {
                if(j > i) {
                  var tmpSubset = topos[layer][group2].filter[topos[layer].uniqueID].top(Infinity);
                  var tmpID2 = tmpSubset.map(function(d) {return d[topos[layer].uniqueID];});

                  if (IDs.length == 0 && i == 0) {
                    IDs = tmpID1.filter(function(val) {
                      return tmpID2.indexOf(val) != -1;
                    });
                  }
                  else {
                    var IDsFilter = IDs.filter(function(val) {
                      return (tmpID1.indexOf(val) != -1 && tmpID2.indexOf(val) != -1);
                    });
                    IDs = IDsFilter;
                  }
                }
              });
            });

            //***Filter groups by common ids
            topos[layer].cfGroup.all.forEach(function(group) {
              topos[layer][group].filter[topos[layer].uniqueID].filterFunction(function(d) { 
                return IDs.indexOf(d) != -1;
              });
            });
          } 
        });


        //******Get featureids by node if a link between crossings and streams is checked
        if(d3.select("#crossings-streams-check").property("checked") == true) {
          var crossNode = topos.crossings[topos.crossings.cfGroup.all[0]].filter.unique_id.top(Infinity).map(function(d) {return d.unique_id;});
          var tmpSubset = topos.streams[topos.streams.cfGroup.all[0]].filter.unique_id.top(Infinity);
          var streamID = tmpSubset.map(function(d) {return d.unique_id;});
          var fromNode = tmpSubset.map(function(d) {return d.from_node;});
          var toNode = tmpSubset.map(function(d) {return d.to_node;});

          var crossIDs = crossNode.filter(function(node, k) {
            return (fromNode.indexOf(node) != -1 || toNode.indexOf(node) != -1);
          });

          var streamIDs = streamID.filter(function(id, k) {
            return (crossNode.indexOf(fromNode[k]) != -1 || crossNode.indexOf(toNode[k]) != -1);
          });

          topos.crossings.cfGroup.all.forEach(function(group) {
            topos.crossings[group].filter.unique_id.filterFunction(function(d) {
              return crossIDs.indexOf(d) != -1;
            });    
          });

          topos.streams.cfGroup.all.forEach(function(group) {
            topos.streams[group].filter.unique_id.filterFunction(function(d) {
              return streamIDs.indexOf(d) != -1;
            });
          });

          var crossNodes = topos.crossings[topos.crossings.cfGroup.all[0]].filter.featureid.top(Infinity).map(function(d){return d.featureid;});
          var streamNodes = topos.streams[topos.streams.cfGroup.all[0]].filter.featureid.top(Infinity).map(function(d){return d.featureid;});
          nodeIDs = crossNodes.filter(function(d) {
            return streamNodes.indexOf(d) != -1;
          });
          //nodeIDs = Array.from(new Set(crossNodes.concat(streamNodes)));
        }


        //******Get common feature ids between linked layers
        IDs = [];
        linkLayers.forEach(function(layer1, i) {
          var tmpSubset = topos[layer1][topos[layer1].cfGroup.all[0]].filter.featureid.top(Infinity);
          var tmpID1 = tmpSubset.map(function(d) {return d["featureid"];});
          linkLayers.forEach(function(layer2, j) {
            if (j > i) {
              var tmpSubset2 = topos[layer2][topos[layer2].cfGroup.all[0]].filter.featureid.top(Infinity);
              var tmpID2 = tmpSubset2.map(function(d) {return d["featureid"];});
              if (IDs.length == 0 && i == 0) {
                if(layer1 == "crossings" && layer2 == "streams") {
                  IDs = nodeIDs;
                }
                else {
                  IDs = tmpID1.filter(function(val) {
                    return tmpID2.indexOf(val) != -1;
                  });
                }
              }
              else {
                if(d3.select("#crossings-streams-check").property("checked") == true) {
                  if(layer1 == "catchments") {
                    var IDsFilter = IDs.filter(function(val) {
                      return (tmpID1.indexOf(val) != -1 && nodeIDs.indexOf(val) != -1);
                    });
                  }
                  else if(layer2 == "catchments") {
                    var IDsFilter = IDs.filter(function(val) {
                      return (nodeIDs.indexOf(val) != -1 && tmpID2.indexOf(val) != -1);
                    });
                  }
                  else {
                    var IDsFilter = IDs.filter(function(val) {
                      return nodeIDs.indexOf(val) != -1;
                    });
                  }
                }
                else {
                  var IDsFilter = IDs.filter(function(val) {
                    return (tmpID1.indexOf(val) != -1 && tmpID2.indexOf(val) != -1);
                  });
                }
                IDs = IDsFilter;
              }
            }
          });
        });


        //******Filter crossfilters by featureid
        linkLayers.forEach(function(layer) {
          topos[layer].cfGroup.all.forEach(function(group) {
            topos[layer][group].filter.featureid.filterFunction(function(d) { 
              return IDs.indexOf(d) != -1;
            });
          });
        });


        return linkLayers;
        //return linkLayers, IDs;
      }



      
      //******Update filter statistics
      function updateStats(tmpKey) {
        //******Update filter mean
        graphs.forEach(function(class_key) {
          var dash = class_key.indexOf("-");
          var tmpClass = class_key.slice(0, dash);
          var key = class_key.slice(dash + 1, class_key.length);
          var topo = topos[tmpClass];

          if (class_key.indexOf(topo.class) > -1 & topo.scale[key] != "categorical") {
            if(topo.cfGroup[key] == "both") {
              var tmpGroup = topo.cfGroup.all[0];
            }
            else {
              var tmpGroup = topo.cfGroup[key];
            }

            if (topo[tmpGroup].filter.all.value() > 0 ) {
              if (topo.data_type[key] == "date") {
                var tmpFormat = d3.time.format("%-m/%-d/%Y")
                d3.select("#mean-" + class_key).html("Mean: " + tmpFormat(new Date(d3.mean(topo[tmpGroup].filter[key].top(Infinity), function(d) { if (d[key] > -9999) {return d[key];} }))));
              }
              else {
                var tmpMean = [d3.mean(topo[tmpGroup].filter[key].top(Infinity), function(d) { if (d[key] > -9999) {return d[key];} })];
                d3.select("#mean-" + class_key).html("Mean: " + backTransformData(topo.scale[key], tmpMean, topo.max[key])[0].toFixed(2));
              }

              if (brush[tmpClass][key].empty()) {
                setInputs(topo, key, topo.minVal[key], topo.maxVal[key], topo.minClip[key], topo.maxClip[key]);
              }
              else {
                setInputs(topo, key, brush[tmpClass][key].extent()[0], brush[tmpClass][key].extent()[1], brush[tmpClass][key].extent()[0], brush[tmpClass][key].extent()[1]);
              }
            }
            else {
              if (topo.data_type[key] == "date") {
                d3.select("#mean-" + class_key).html("Mean: 0/0/0000");
              }
              else {
                d3.select("#mean-" + class_key).html("Mean: 0.00");
              }
            }
          }  
        });
      }




      //******Update filter histogram based on current brush
      function updateHistogram(tmpKey) {
        graphs.forEach(function(class_key) {
          var dash = class_key.indexOf("-");
          var tmpClass = class_key.slice(0, dash);
          var key = class_key.slice(dash + 1, class_key.length);
          var topo = topos[tmpClass];

          if (class_key.indexOf(topo.class) > -1) { 
            if (class_key != topo.class + "-" + tmpKey) {
              redrawHist(key, topo);
            }
          }
        });
      }

      //******Redraw the histogram
      function redrawHist(key, topo) {
        if(topo.cfGroup[key] == "both") {
          var tmpGroup = topo.cfGroup.all[0];
        }
        else {
          var tmpGroup = topo.cfGroup[key];
        }

        //******If brush or catFilters are present, remove it and get featureID's, then add it back
        if (!brush[topo.class][key].empty()) {
          topo[tmpGroup].filter[key].filterAll();
          var linkLayers, IDs = getLinkIDs();
          var tmpData = JSON.parse(JSON.stringify(topo[tmpGroup].filter[key + "s"].all()));
          topo[tmpGroup].filter[key].filterRange([brush[topo.class][key].extent()[0], brush[topo.class][key].extent()[1]]);
          var linkLayers, IDs = getLinkIDs();
        }
        else if(topo.scale[key] == "categorical" && topo.catFilter[key].length != topo.binCount[key].length) {
          topo[tmpGroup].filter[key].filterAll();
          var linkLayers, IDs = getLinkIDs();
          var tmpData = JSON.parse(JSON.stringify(topo[tmpGroup].filter[key + "s"].all()));
          topo[tmpGroup].filter[key].filterFunction(function(d) {return topo.catFilter[key].indexOf(d) > -1; });
          var linkLayers, IDs = getLinkIDs();
        }
        else {
          var tmpData = topo[tmpGroup].filter[key + "s"].all();
        }

        var svg = d3.select("#g-" + topo.class + "-" + key);
        var x = hist[topo.class][key].x;
        var y = hist[topo.class][key].y;
        var height = hist[topo.class][key].height;
        var width = hist[topo.class][key].width;
        y.domain([0, d3.max(tmpData, function(d) { if (d.key > -9999) { return d.value; } })]);

        //******update background bars
        if(topo.scale[key] != "categorical") {
          var update = svg.selectAll(".background.bar")
            .data(tmpData);

          update.exit().remove();
          update.enter().insert("rect", ":first-child")
            .attr("class", "background bar");
          update
            .attr("x", function(d) { return x(d.key); })
            .attr("width", function() { if(topo.scale[key] == "categorical") { return x.rangeBand(); } else { return width / topo.binCount[key]; } }) 
            .attr("y", function(d) { return y(d.value); })
            .attr("height", function(d) { return height - y(d.value); });
        }
        else {
          tmpData = tmpData.filter(function(d) { return d.key > -9999; });
        }

        //******update foreground bars
        var update = svg.selectAll(".foreground.bar")
          .data(tmpData);

        update.exit().remove();
        update.enter().insert("rect", ":first-child")
          .attr("class", "foreground bar")
          .on("mouseover", function() { if(topo.scale[key] == "categorical") { d3.select(this).style("cursor", "crosshair"); } })
          .on("click", function() { catBarStyle(topo, key, this); });

        update
          .attr("x", function(d) { return x(d.key); })
          .attr("width", function() { if(topo.scale[key] == "categorical") { return x.rangeBand(); } else { return width / topo.binCount[key]; } }) 
          .attr("y", function(d) { return y(d.value); })
          .attr("height", function(d) { return height - y(d.value); })
          .style("fill", function(d) { if(topo.scale[key] == "categorical") { if(topo.catFilter[key].indexOf(d.key) != -1) { return "steelblue"; } else { return "#ccc"; } } else { return ""; } })
          .select("title").text(function(d) { return topo.conversion[key][d.key] + ": " + d.value; });
      }

      function catBarStyle(topo, key, tmpBar) {
        if(topo.scale[key] == "categorical") { 
          var bars = d3.select("#g-" + topo.class + "-" + key).selectAll(".foreground.bar");
          var visBars = bars.filter(function() { return parseFloat(d3.select(this).attr("height")) > 0; });
          //var visBars = bars.filter(function() { return d3.select(this).datum().value > 0; });
          var blueBars = visBars.filter(function() { return d3.select(this).style("fill") == "rgb(70, 130, 180)"; });

          if(blueBars[0].length == visBars[0].length) {
            bars.style({"fill":"#ccc","stroke":"#ccc"});
            d3.select(tmpBar).style({"fill":"steelblue","stroke":"steelblue"});
            topo.catFilter[key] = [d3.select(tmpBar).datum().key];
          }
          else if(d3.select(tmpBar).style("fill") == "rgb(70, 130, 180)" && blueBars[0].length == 1) {
            bars.style({"fill":"steelblue","stroke":"steelblue"});
            //topo.catFilter[key] = bars.data().map(function(d) { return d.key; });
          }
          else {
            //***if bar is blue
            if(d3.select(tmpBar).style("fill") == "rgb(70, 130, 180)") {
              d3.select(tmpBar).style({"fill":"#ccc","stroke":"#ccc"});
              topo.catFilter[key].splice(topo.catFilter[key].indexOf(d3.select(tmpBar).datum().key), 1);
            }
            else {
              //***if bar is gray
              d3.select(tmpBar).style({"fill":"steelblue","stroke":"steelblue"});
              topo.catFilter[key].push(d3.select(tmpBar).datum().key);
            }
          }

          var blueBars = visBars.filter(function() { return d3.select(this).style("fill") == "rgb(70, 130, 180)"; });

          if(blueBars[0].length == visBars[0].length) {
            brushReset(key, topo);
          }
          else {
            d3.select("#reset-" + topo.class + "-" + key).style("display", "inline-block");
            brushEnd(key, topo);
          }
        } 
      }

      function startIntro(){
        var intro = introJs();
        intro.setOptions({
          steps: [
            { 
              //0
              intro: '<h4>Welcome to the Stream Crossings Explorer tool!<h4><br><p style="font-size:11px"><b>Disclaimer:</b> This project and tool are still under development.</p>'
            },
            { 
              //1
              intro: '<h4><b><u>Keywords</u></b></h4><br><p><u>Layer:</u> A collection of features of a specific class (e.g. crossings, streams, or catchments).</p><br><p><u>Feature:</u> A representation of a real-world object on a map.</p><br><p><u>Attribute:</u> Information about a feature (e.g. risk of failure, stream temperature, or elevation).</p>'
            },
            {
              //2
              element: document.querySelector('#headerControls'),
              intro: '<h4><b><u>Interactive Controls</b></u></h4><br><p>Controls that allow the user to interact with the map and data are located in the top toolbar.',
              position: 'bottom'
            },
            {
              //3
              element: document.querySelector('#mapTools'),
              intro: '<h4><b><u>Map Controls</b></u></h4><br><p>Enable the user to change the map baselayer, add overlay layers, and search the map by name, zip code or coordinates.',
              position: 'bottom'
            },
            {
              //4
              element: document.querySelector('#panelTools'),
              intro: '<h4><b><u>Data Controls</b></u></h4><br><p>Show or hide tools that enable the user to interact with the data through mapping, filtering, and viewing attribute values for crossing, stream and catchment features.',
              position: 'bottom'
            },
            {
              //5
              element: document.querySelector('#hcAttrSelectDiv'),
              intro: "<h4><b><u>Select Attributes Window</b></u></h4><br><p>This icon shows/hides the Attribute Selection panel.</p>",
            },
            {
              //6
              element: document.querySelector('#attrSelectDiv'),
              intro: '<h4><b><u>Attribute Selection Panel</b></u></h4><br><p>Shows all of the attributes available for each layer. Check the attribute to make it available for use with the Layers and Charts windows.</p>',
              position: 'left'
            },
            {
              //7
              element: document.querySelector('#hcLegendDiv'),
              intro: "<h4><b><u>Layers Window</b></u></h4><br><p>This icon shows/hides the Layers window.</p>",
            },
            {
              //8
              element: document.querySelector('#legendDiv'),
              intro: "<h4><b><u>Layers Window</b></u></h4><br><p>Controls which attribute is displayed on the map for a layer's features and shows a legend for value interpretation.</p>",
            },
            {
              //9
              element: document.querySelector('#crossingsSwitch'),
              intro: '<h4><b><u>Layer Display</b></u></h4><br><p>To add/remove a feature layer from the map click here to turn it on or off.</p>',
              position: 'bottom'
            },
            {
              //10
              element: document.querySelector('#crossingsSelect'),
              intro: '<h4><b><u>Attribute Mapping</b></u></h4><br><p>Change the current selection in the dropdown list to display different attribute values for features on the map.</p>',
              position: 'right'
            },
            {
              //11
              element: document.querySelector('#crossingsSlider'),
              intro: '<h4><b><u>Layer Transparency</b></u></h4><br><p>To change the transparency of a layer, simply adjust the slider bar.</p>',
              position: 'bottom'
            },
            {
              //12
              element: document.querySelector('#hcChartsDiv'),
              intro: "<h4><b><u>Charts Window</b></u></h4><br><p>This icon shows/hides the Charts window.</p>",
            },
            {
              //13
              element: document.querySelector('#chartsDiv'),
              intro: "<h4><b><u>Charts Window</b></u></h4><br><p>Enables the user to graphically view the distribution of an attribute's values and choose which ones are shown on the map.</p>",
              position: 'left'
            },
            {
              //14
              element: document.querySelector('#addChartsDivButton'),
              intro: '<h4><b><u>Add Chart</b></u></h4><br><p>Click the Add Chart Data button to create a graph of the value distribution for an attribute.</p>',
              position: 'left'
            },
            {
              //15
              element: document.querySelector('#filterLayers'),
              intro: "<h4><b><u>Graph Distribution</b></u></h4><br><p>Choose a layer and an attribute to add a graph showing a distribution of the attribute's values.</p>",
              position: 'left'
            },
            {
              //16
              element: document.querySelector('#charts'),
              intro: '<h4><b><u>Filter Features</b></u></h4><br><p>Specify attribute values directly by typing them in the boxes or by using your mouse to interact with the graph to filter map features to only those that meet the criteria.</p>',
              position: 'left'
            },
            {
              //17
              element: document.querySelector('#totals'),
              intro: '<h4><b><u>Feature Counts</b></u></h4><br><p>Expand the Selection Counts window to view how many features meet the attribute specifications.</p>',
              position: 'left'
            },
            {
              //18
              element: document.querySelector('#linkLayers'),
              intro: "<h4><b><u>Spatial Joins</b></u></h4><br><p>Spatial joins provide the ability to filter features in one layer based on attribute values of another, geographically overlapping layer. View the instructional video under the 'About SCE' link for more details.</p>",
              position: 'left'
            },
            {
              //19
              element: document.querySelector('#hcPolFilterDiv'),
              intro: "<h4><b><u>Geographic Filter Window</b></u></h4><br><p>This icon shows/hides the Geographic Filter window.</p>",
              position: 'bottom'
            },
            {
              //20
              element: document.querySelector('#polFilterDiv'),
              intro: '<h4><b><u>Geographic Filter</b></u></h4><br><p>Restricts features on the map to the specified areas for political and hydrologic boundary classes.</p>',
              position: 'right'
            },
            {
              //21
              element: document.querySelector('#hcAttributesDiv'),
              intro: "<h4><b><u>Feature Attributes Window</b></u></h4><br><p>This icon shows/hides the Feature Attributes window.</p>",
            },
             {
              //22
              element: document.querySelector('#attributesDiv'),
              intro: '<h4><b><u>Feature Attributes Window</b></u></h4><br><p>Click on a feature to see either currently selected or all attribute values.</p>',
              position: 'right'
            },
            {
              //23
              element: document.querySelector('#printDownload'),
              intro: '<h4><b><u>Output Controls</b></u></h4><br><p>Controls for downloading current map features in your preferred output format, printing the current map, or saving it to a PDF.</p>',
              position: 'left'
            },
            {
              //24
              element: document.querySelector('#showDetails'),
              intro: "<h4><b><u>Tool Information</b></u></h4><br><p>Click on 'About SCE' to display detailed information about this tool and view instructional videos.</p>",
              position: 'left'
            },
            {
              //25
              element: document.querySelector('#launchIntro'),
              intro: '<h4><b><u>Tutorial</b></u></h4><br><p>Click on "Tutorial" to relaunch this introduction.</p>',
              position: 'left'
            },
            {
              //26
              intro: '<h4><b><u>Stream Crossings Explorer</b></u></h4><br><p>Thank you for using our tool, enjoy!</p>'
            }
          ],
          tooltipPosition: 'auto',
          positionPrecedence: ['left', 'right', 'bottom', 'top'],
          showStepNumbers: false
        });

        intro.onbeforechange(function() { 
          switch (this._currentStep) {
            case 0:                              
              hideWindows();
              map.setView(new L.LatLng(42.74, -72.83), 10);
              break;
          }  
        });

        intro.onchange(function() { 
          hideWindows();
          switch (this._currentStep) {
            case 4:
              d3.selectAll(".hcPanelDivs").style("color","blue");
              break;
            case 5:
              d3.select("#hcAttrSelectDiv").style("color","blue");
              //d3.select("#attrSelectModal").classed("in", true).style("display", "flex");
              break;
            case 6:
              d3.select("#attrSelectModal").classed("in", true).style("display", "flex");
              break;
            case 7:
              d3.select("#hcLegendDiv").style("color","blue");
              d3.select("#legendDiv").style("visibility", "visible");
              break;
            case 8:
              d3.select("#legendDiv").style("visibility", "visible");
              break;
            case 9:
              d3.select("#legendDiv").style("visibility", "visible");
              d3.select("#crossingsLayerChk").property("checked", true);
              break;
            case 10:
              d3.select("#legendDiv").style("visibility", "visible");
              break;
            case 11:
              d3.select("#legendDiv").style("visibility", "visible");
              break;
            case 12:
              d3.select("#hcChartsDiv").style("color","blue");
              d3.select("#chartsDiv").style("visibility", "visible");
              break;
            case 13:
              d3.select("#chartsDiv").style("visibility", "visible");
              break;
            case 14:
              d3.select("#chartsDiv").style("visibility", "visible");
              break;
            case 15:
              d3.select("#chartsDiv").style("visibility", "visible");
              d3.select("#filterLayers").style({"display": "block"});
              break;
            case 16:
              d3.select("#chartsDiv").style("visibility", "visible");
              d3.select("#layerFilterSelect").property("selectedIndex", 1)
              addFilterSelect(topos[d3.select("#layerFilterSelect").node().value]);
              d3.select("#attributeFilterSelect").property("selectedIndex", 1)
              addFilter(d3.select("#attributeFilterSelect").node().value, topos[d3.select("#layerFilterSelect").node().value]);
              d3.select("#charts").classed("in", true);
              changeGlyph(document.getElementById("distributionsGlyph"));
              break;
            case 17:
              d3.select("#chartsDiv").style("visibility", "visible");
              d3.select("#totals").classed("in", true);
              changeGlyph(document.getElementById("totalsGlyph"));
              d3.select("#layerFilterSelect").property("selectedIndex", 1)
              addFilterSelect(topos[d3.select("#layerFilterSelect").node().value]);
              d3.select("#attributeFilterSelect").property("selectedIndex", 1)
              addFilter(d3.select("#attributeFilterSelect").node().value, topos[d3.select("#layerFilterSelect").node().value]);
              //***Add brush
              var tmpLo = d3.select("#extent-input-lower-" + d3.select("#layerFilterSelect").node().value + "-" + d3.select("#attributeFilterSelect").node().value);
              var tmpHi = d3.select("#extent-input-upper-" + d3.select("#layerFilterSelect").node().value + "-" + d3.select("#attributeFilterSelect").node().value);
              var tmpRange = parseFloat(tmpHi.property("value")) - parseFloat(tmpLo.property("value"));
              tmpLo.property("value", (parseFloat(tmpLo.property("value")) + (tmpRange * 0.2)).toFixed(2));
              tmpHi.property("value", (parseFloat(tmpHi.property("value")) - (tmpRange * 0.2)).toFixed(2));
              extentChange(d3.select("#attributeFilterSelect").node().value, topos[d3.select("#layerFilterSelect").node().value], tmpLo, tmpHi);
              break;
            case 18:
              d3.select("#chartsDiv").style("visibility", "visible");
              d3.select("#layerFilterSelect").property("selectedIndex", 1)
              addFilterSelect(topos[d3.select("#layerFilterSelect").node().value]);
              d3.select("#attributeFilterSelect").property("selectedIndex", 1)
              addFilter(d3.select("#attributeFilterSelect").node().value, topos[d3.select("#layerFilterSelect").node().value]);
              //***Add brush
              var tmpLo = d3.select("#extent-input-lower-" + d3.select("#layerFilterSelect").node().value + "-" + d3.select("#attributeFilterSelect").node().value);
              var tmpHi = d3.select("#extent-input-upper-" + d3.select("#layerFilterSelect").node().value + "-" + d3.select("#attributeFilterSelect").node().value);
              var tmpRange = parseFloat(tmpHi.property("value")) - parseFloat(tmpLo.property("value"));
              tmpLo.property("value", (parseFloat(tmpLo.property("value")) + (tmpRange * 0.2)).toFixed(2));
              tmpHi.property("value", (parseFloat(tmpHi.property("value")) - (tmpRange * 0.2)).toFixed(2));
              extentChange(d3.select("#attributeFilterSelect").node().value, topos[d3.select("#layerFilterSelect").node().value], tmpLo, tmpHi);
              d3.select("#linkLayers").classed("in", true);
              changeGlyph(document.getElementById("sjGlyph"));
              d3.select("#crossings-streams-check").property("checked", true);
              checkLink("featureid", "crossings", true);
              d3.select("#layerFilterSelect").property("selectedIndex", 1)
              addFilterSelect(topos[d3.select("#layerFilterSelect").node().value]);
              d3.select("#attributeFilterSelect").property("selectedIndex", 1)
              addFilter(d3.select("#attributeFilterSelect").node().value, topos[d3.select("#layerFilterSelect").node().value]);
              d3.select("#layerFilterSelect").property("selectedIndex", 2)
              addFilterSelect(topos[d3.select("#layerFilterSelect").node().value]);
              d3.select("#attributeFilterSelect").property("selectedIndex", 1)
              addFilter(d3.select("#attributeFilterSelect").node().value, topos[d3.select("#layerFilterSelect").node().value]);
              break;
            case 19:
              d3.select("#polFilterDiv").style("visibility", "visible");
              d3.select("#hcPolFilterDiv").style("color","blue");
              break;
            case 20:
              addPolFilter(topos.political,"state","Massachusetts");
              d3.select("#polFilterDiv").style("visibility", "visible");
              break;
            case 21:
              d3.select("#attributesDiv").style("visibility", "visible"); 
              d3.select("#hcAttributesDiv").style("color","blue");
              d3.select(".introjs-tooltip").classed("introjs-tooltip-reposition", true);
              break;
            case 22:
              //d3.selectAll("#attributesDiv,.d3Tooltip,.header,#headerControls").style("z-index", "9999999");
              d3.select("#attributesDiv").style("visibility", "visible");
              getAttributes(crossingCov[0],topos.crossings,1);
              break; 
            case 23:
              d3.selectAll("#downloadControl,#printControl").style("color", "blue");
              break;
            case 24:
              d3.select("#showDetails").style("color", "blue");
              d3.select("#helpDiv").classed("in", true).style("display", "flex");
              break;
            case 25:
              d3.select("#launchIntro").style("color", "blue");
              break;
          }
        });

        intro.onafterchange(function(tmpEl) { 
          switch (this._currentStep) {
          }
        });

        intro.oncomplete(function() { 
          localStorage.setItem('doneTour', 'yeah!'); 
          exitTutorial();
        });

        intro.onexit(function() {
          exitTutorial();
          disableTutorialSession = true;
        });            

        intro.start();

        function hideWindows() {
          ["crossings","streams","catchments"].forEach(function(d) {
            if(d3.select("#" + d + "LayerChk").property("checked") == false) {
              $('#' + d + 'LayerChk').bootstrapToggle('on');
            }
            d3.select("#" + d + "Slider").property("value", "100");
            layerOpacity(d3.select("#" + d + "Slider")[0][0],topos[d]);
          });

          var tmpWins = ["legend", "attributes", "polFilter", "charts", "download"];
          tmpWins.forEach(function(win) {
            d3.select("#" + win + "Div").style({"opacity":"1", "display":"block", "visibility":"hidden"});
          });
          d3.select("#attrSelectModal").classed("in", false).style("display", "none");
          d3.select("#helpDiv").classed("in", false).style("display", "none");
          d3.selectAll(".hcPanelDivs").style("color","");
          d3.select("#filterLayers").style("display","none");
          d3.select("#attributesDiv").style("z-index", "1000");
          d3.select(".d3Tooltip,.header,#headerControls").style("z-index", ""); 
          d3.selectAll("#downloadControl,#printControl").style("color", "");
          d3.select("#showDetails").style("color", "");
          d3.select("#launchIntro").style("color", "");
        }    

        function exitTutorial() {
          hideWindows();

          var tmpWins = ["legend", "attributes", "polFilter", "charts", "download"];
          tmpWins.forEach(function(win) {
            d3.select("#" + win + "Div").style({"opacity":"0"});
          });
 
          toolWindowToggle("legend");

          //***Regional Filter Window
          var tmpArray = topos.political.condition.slice();
          tmpArray.forEach(function(cond) {
            var i = cond.indexOf("-") + 1;
            var j = cond.lastIndexOf("-");
            removeCondition(topos.political, cond, cond.slice(i,j), cond.slice(j+1)); 
          });

          //***Charts Window
          d3.select("#crossings-streams-check").property("checked", false);
          checkLink("featureid", "crossings", true);
          var tmpArray = graphs.slice();
          tmpArray.forEach(function(graph) {
            var i = graph.indexOf("-");
            removeFilter(graph, topos[graph.slice(0,i)]);
          });

          //***Open attribute selection if first time through tutorial
          if(disableTutorialSession != true) {
            $('#attrSelectModal').modal('show');
          }
        }     
      }      
    </script>
  </body>
</html>